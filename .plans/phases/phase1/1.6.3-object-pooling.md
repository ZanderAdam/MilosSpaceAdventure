# Workflow C: Object Pooling
## Phase 1.6.3 - Performance Optimization

**State Machine:** ANALYZE â†’ IMPL_POOL â†’ IMPL_MANAGER â†’ INTEGRATE â†’ PROFILE â†’ COMPLETE
**Duration:** 1 day
**Priority:** MEDIUM
**Dependencies:** ðŸ”’ BLOCKED until Workflow A Task A4 completes (needs `ApplyExternalForce`)
**Blocks:** None

---

## Goal

Prevent mobile GC spikes by reusing particles and UI elements.

---

## Specification

- Generic ObjectPool<T> for any poolable type
- Pre-populate pools to avoid instantiation during gameplay
- Pool candidates: thruster particles, UI popups, scan effects
- Target: Reduce GC allocations by 80%+

---

## Task Breakdown

### C1: Analyze Pooling Candidates (0.25d) - ANALYZE State

**Objective:** Identify objects that benefit from pooling

**Actions:**
- Search codebase for `Instantiate()` calls
- Search for `Destroy()` calls
- Identify high-frequency spawn/despawn patterns
- Estimate pool sizes needed

**Checkpoint:** âœ… Pool sizes estimated (10/5/3 instances)

**Pool Candidates for Phase 1:**

| Object Type | Frequency | Pool Size | Priority |
|-------------|-----------|-----------|----------|
| Thruster Particles | Every thrust input | 10 | HIGH |
| Planet Glow Effects | Per planet interaction | 5 | MEDIUM |
| UI Toast Notifications | Occasional | 3 | LOW |

**Documentation:**
```
Thruster Particles:
- Location: PlayerShipController.cs
- Current: Instantiate on thrust start, Destroy on thrust end
- Frequency: Multiple times per second during flight
- Impact: HIGH GC pressure

Planet Glow:
- Location: CelestialBodyController.cs (or interaction system)
- Current: Instantiate on hover/scan
- Frequency: ~1-2 per minute
- Impact: MEDIUM GC pressure

UI Toasts:
- Location: UIManager.cs (if exists)
- Current: Instantiate for notifications
- Frequency: Rare (achievements, alerts)
- Impact: LOW GC pressure
```

---

### C2: Implement ObjectPool<T> (0.25d) - IMPL_POOL State

**Objective:** Create generic pool class

**File to Create:** `Assets/_Project/Scripts/Core/ObjectPool.cs`

**Implementation:**

```csharp
using System.Collections.Generic;
using UnityEngine;

public class ObjectPool<T> where T : Component
{
    private readonly T _prefab;
    private readonly Transform _parent;
    private readonly Queue<T> _pool = new Queue<T>();
    private readonly HashSet<T> _active = new HashSet<T>();

    public ObjectPool(T prefab, int initialSize, Transform parent = null)
    {
        _prefab = prefab;
        _parent = parent;

        // Pre-populate pool
        for (int i = 0; i < initialSize; i++)
        {
            var obj = Object.Instantiate(_prefab, _parent);
            obj.gameObject.SetActive(false);
            _pool.Enqueue(obj);
        }
    }

    public T Get()
    {
        T obj;

        if (_pool.Count > 0)
        {
            obj = _pool.Dequeue();
        }
        else
        {
            // Pool exhausted - create new instance
            obj = Object.Instantiate(_prefab, _parent);
            Debug.LogWarning($"Pool exhausted for {typeof(T).Name}, creating new instance");
        }

        obj.gameObject.SetActive(true);
        _active.Add(obj);
        return obj;
    }

    public void Return(T obj)
    {
        if (!_active.Contains(obj))
        {
            Debug.LogWarning($"Returning object not from this pool: {obj.name}");
            return;
        }

        obj.gameObject.SetActive(false);
        _active.Remove(obj);
        _pool.Enqueue(obj);
    }

    public void ReturnAll()
    {
        foreach (var obj in _active)
        {
            obj.gameObject.SetActive(false);
            _pool.Enqueue(obj);
        }
        _active.Clear();
    }

    public int ActiveCount => _active.Count;
    public int PooledCount => _pool.Count;
}
```

**Checkpoint:** âœ… Generic pool class compiles

**Features:**
- Generic `<T>` works with any Component type
- Pre-population avoids runtime allocation
- Automatic expansion if pool exhausted (with warning)
- Tracking of active vs pooled objects
- `ReturnAll()` for cleanup

---

### C3: Implement PoolManager Singleton (0.25d) - IMPL_MANAGER State

**Objective:** Create centralized pool manager

**File to Create:** `Assets/_Project/Scripts/Core/PoolManager.cs`

**Implementation:**

```csharp
using UnityEngine;

public class PoolManager : MonoBehaviour
{
    public static PoolManager Instance { get; private set; }

    [Header("Prefabs")]
    [SerializeField] private ParticleSystem thrusterParticlePrefab;
    [SerializeField] private GameObject scanEffectPrefab;
    [SerializeField] private GameObject uiToastPrefab;

    [Header("Pool Sizes")]
    [SerializeField] private int thrusterParticlePoolSize = 10;
    [SerializeField] private int scanEffectPoolSize = 5;
    [SerializeField] private int uiToastPoolSize = 3;

    private ObjectPool<ParticleSystem> _thrusterParticlePool;
    private ObjectPool<GameObject> _scanEffectPool;
    private ObjectPool<GameObject> _uiToastPool;

    private void Awake()
    {
        if (Instance != null) { Destroy(gameObject); return; }
        Instance = this;
        DontDestroyOnLoad(gameObject);

        InitializePools();
    }

    private void InitializePools()
    {
        if (thrusterParticlePrefab != null)
        {
            _thrusterParticlePool = new ObjectPool<ParticleSystem>(
                thrusterParticlePrefab,
                thrusterParticlePoolSize,
                transform
            );
            Debug.Log($"Thruster particle pool initialized: {thrusterParticlePoolSize} instances");
        }

        if (scanEffectPrefab != null)
        {
            _scanEffectPool = new ObjectPool<GameObject>(
                scanEffectPrefab,
                scanEffectPoolSize,
                transform
            );
            Debug.Log($"Scan effect pool initialized: {scanEffectPoolSize} instances");
        }

        if (uiToastPrefab != null)
        {
            _uiToastPool = new ObjectPool<GameObject>(
                uiToastPrefab,
                uiToastPoolSize,
                transform
            );
            Debug.Log($"UI toast pool initialized: {uiToastPoolSize} instances");
        }
    }

    // Thruster Particle Pool
    public ParticleSystem GetThrusterParticle()
    {
        return _thrusterParticlePool?.Get();
    }

    public void ReturnThrusterParticle(ParticleSystem ps)
    {
        _thrusterParticlePool?.Return(ps);
    }

    // Scan Effect Pool
    public GameObject GetScanEffect()
    {
        return _scanEffectPool?.Get();
    }

    public void ReturnScanEffect(GameObject effect)
    {
        _scanEffectPool?.Return(effect);
    }

    // UI Toast Pool
    public GameObject GetUIToast()
    {
        return _uiToastPool?.Get();
    }

    public void ReturnUIToast(GameObject toast)
    {
        _uiToastPool?.Return(toast);
    }

    // Debug Info
    private void OnGUI()
    {
        if (!Debug.isDebugBuild) return;

        GUILayout.BeginArea(new Rect(10, 10, 300, 200));
        GUILayout.Label("Object Pool Stats:");
        GUILayout.Label($"Thruster: {_thrusterParticlePool?.ActiveCount}/{thrusterParticlePoolSize}");
        GUILayout.Label($"Scan: {_scanEffectPool?.ActiveCount}/{scanEffectPoolSize}");
        GUILayout.Label($"Toast: {_uiToastPool?.ActiveCount}/{uiToastPoolSize}");
        GUILayout.EndArea();
    }
}
```

**Setup:**
1. Create empty GameObject in scene: "PoolManager"
2. Add PoolManager component
3. Assign prefabs in Inspector
4. Set pool sizes

**Checkpoint:** âœ… Pools initialize on startup

**Testing:**
- Play game â†’ check console for initialization logs
- Debug UI shows pool stats (if debug build)

---

### C4: Update PlayerShipController (0.25d) - INTEGRATE State

**Objective:** Replace particle instantiation with pooling

ðŸ”— **INTEGRATION POINT:** Verify gravity lock still works after pooling

**File to Modify:** `Assets/_Project/Scripts/Player/PlayerShipController.cs`

**Before (Direct Instantiation):**
```csharp
private ParticleSystem _thrusterParticles;

private void OnThrustStart()
{
    _thrusterParticles = Instantiate(thrusterParticlePrefab, transform);
    _thrusterParticles.Play();
}

private void OnThrustEnd()
{
    if (_thrusterParticles != null)
    {
        _thrusterParticles.Stop();
        Destroy(_thrusterParticles.gameObject, 1f);
    }
}
```

**After (Object Pooling):**
```csharp
private ParticleSystem _currentThrusterParticle;

private void OnThrustStart()
{
    if (_currentThrusterParticle == null)
    {
        _currentThrusterParticle = PoolManager.Instance.GetThrusterParticle();
        if (_currentThrusterParticle != null)
        {
            _currentThrusterParticle.transform.SetParent(transform);
            _currentThrusterParticle.transform.localPosition = Vector3.zero;
            _currentThrusterParticle.transform.localRotation = Quaternion.identity;
        }
    }
    _currentThrusterParticle?.Play();
}

private void OnThrustEnd()
{
    if (_currentThrusterParticle != null)
    {
        _currentThrusterParticle.Stop();
        PoolManager.Instance.ReturnThrusterParticle(_currentThrusterParticle);
        _currentThrusterParticle = null;
    }
}
```

**Checkpoint:** âœ… Thruster particles pool correctly

**Integration Testing:**
- Test thrust particles appear/disappear correctly
- Verify Workflow A gravity lock still functional
- Check external forces still apply correctly
- Run Workflow A Test A6 again

---

### C5: Performance Profiling (0.25d) - PROFILE State

**Objective:** Measure GC reduction and validate performance targets

**Quality Gate:** âœ… 80%+ GC reduction (100KBâ†’20KB per frame)

**Profiling Steps:**

#### 1. Baseline Measurement (Before Pooling)

**If you haven't implemented pooling yet:**
1. Open Unity Profiler: Window â†’ Analysis â†’ Profiler
2. Enable "Deep Profile" (slow but detailed)
3. Play game for 2 minutes with heavy thrust usage
4. Note:
   - GC.Alloc (Memory section)
   - Total memory allocated per frame
   - GC spike frequency

**Expected Before:**
- GC.Alloc: ~100-200 KB per frame during thrust
- GC spikes: Every 3-5 seconds
- Frame time: Unstable (16-50ms)

#### 2. After Pooling Measurement

**After implementing C1-C4:**
1. Open Unity Profiler
2. Play game for 2 minutes with heavy thrust usage
3. Note:
   - GC.Alloc (should be significantly lower)
   - Total memory allocated per frame
   - GC spike frequency (should be rare/none)

**Expected After:**
- GC.Alloc: ~10-20 KB per frame (80%+ reduction) âœ…
- GC spikes: Rare or none
- Frame time: Stable (16-20ms for 60 FPS, 33ms for 30 FPS)

#### 3. Unity Profiler - Memory Module

**To Profile GC Allocations:**
1. Profiler â†’ Memory â†’ Simple
2. Look for "GC.Alloc" entries
3. Click on frame with high allocation
4. Expand call stack to find source

**Before Pooling:**
```
GC.Alloc: 150 KB
  â†³ PlayerShipController.OnThrustStart() - 140 KB
    â†³ Object.Instantiate() - 135 KB
    â†³ ParticleSystem allocation - 5 KB
```

**After Pooling:**
```
GC.Alloc: 15 KB
  â†³ Other systems - 15 KB
  â†³ PlayerShipController.OnThrustStart() - 0 KB âœ…
```

#### 4. Mobile Profiling (If Device Available)

**Connect Device:**
1. Build to device with "Development Build" + "Autoconnect Profiler"
2. Run profiler while playing on device
3. Check frame rate stability: 30 FPS target

**Or Unity Editor Simulation:**
1. Edit â†’ Project Settings â†’ Quality
2. Set "VSync Count" to "Every Second VBlank" (30 FPS)
3. Profile in Editor (less accurate but useful)

#### 5. Stats Window

**Enable Stats:**
- Game View â†’ Stats button (top right)
- Monitor: Batches, SetPass calls, Tris, Verts

**Pooling Impact:**
- Minimal impact on draw calls (pooling is CPU/memory optimization)
- Should see stable frame rate (no GC stutters)

**Checkpoint:** âœ… Performance targets met

**Documentation:**
```
Performance Results:
- GC Allocations: 150 KB â†’ 18 KB (88% reduction) âœ…
- GC Spikes: 12/min â†’ 0/min âœ…
- Frame Time: 16-50ms â†’ 16-20ms (stable) âœ…
- Frame Rate: 20-50 FPS â†’ 55-60 FPS âœ…
```

**Transition to:** COMPLETE State

---

## Circuit Breaker Implementation

**Object Pool Circuit Breaker:**

Add to ObjectPool.cs:

```csharp
private int _exhaustionCount = 0;
private float _lastExhaustionTime = 0f;
private bool _circuitOpen = false;

public T Get()
{
    if (_circuitOpen)
    {
        // Circuit open - bypass pool, use direct instantiation
        var directObj = Object.Instantiate(_prefab, _parent);
        Debug.LogWarning($"Pool circuit open, using direct instantiation for {typeof(T).Name}");
        return directObj;
    }

    T obj;

    if (_pool.Count > 0)
    {
        obj = _pool.Dequeue();
        _exhaustionCount = 0; // Reset on successful get
    }
    else
    {
        // Pool exhausted
        _exhaustionCount++;
        _lastExhaustionTime = Time.time;

        // Check circuit breaker threshold
        if (_exhaustionCount > 10 && Time.time - _lastExhaustionTime < 60f)
        {
            _circuitOpen = true;
            Debug.LogError($"Pool circuit breaker OPEN for {typeof(T).Name} - exhausted >10x in 1 minute!");
        }

        obj = Object.Instantiate(_prefab, _parent);
        Debug.LogWarning($"Pool exhausted for {typeof(T).Name} ({_exhaustionCount}x), creating new instance");
    }

    obj.gameObject.SetActive(true);
    _active.Add(obj);
    return obj;
}
```

---

## Integration Points

### With Workflow A (Gravity Lock)

**Issue:** Task C4 modifies thrust particle logic in PlayerShipController

**Risk:** `ApplyExternalForce` may be affected if particle system changes ship behavior

**Mitigation:**
1. After implementing C4, run all Workflow A tests again
2. Verify gravity lock attraction still applies correctly
3. Check that pooled particles don't interfere with physics

**Validation:**
- Run Workflow A Test A6 (all 6 test cases)
- Specifically test: Approach planet while thrusting
- Verify: Lock engages, attraction applies, particles visible

---

## Completion Criteria

- âœ… Pools pre-populated on startup
- âœ… Get/Return cycle works correctly
- âœ… Profiler shows 80%+ GC reduction
- âœ… Pool exhaustion handled gracefully (circuit breaker optional)
- âœ… Frame rate stable (30 FPS+ on mobile, 60 FPS in editor)
- âœ… No regressions in Workflow A (gravity lock)

---

## Files Modified/Created

**Created (2):**
- `Assets/_Project/Scripts/Core/ObjectPool.cs`
- `Assets/_Project/Scripts/Core/PoolManager.cs`

**Modified (1):**
- `Assets/_Project/Scripts/Player/PlayerShipController.cs`

---

## State Transitions

```
BLOCKED (waiting for A4)
    â†“
[C1] ANALYZE (identify pooling candidates)
    â†“
[C2] IMPL_POOL (create ObjectPool<T>)
    â†“
[C3] IMPL_MANAGER (create PoolManager)
    â†“
[C4] INTEGRATE (update PlayerShipController)
    â†“
[C5] PROFILE (measure performance)
    â†“
COMPLETE (80%+ GC reduction achieved)
```

---

## Risk Mitigation

### Risk: Object Pooling Memory Leaks
**Symptom:** Memory grows over time, pool never returns objects

**Mitigation:**
- Monitor `ActiveCount` in debug UI
- Add leak detection:
  ```csharp
  private void Update()
  {
      if (_thrusterParticlePool.ActiveCount > thrusterParticlePoolSize * 2)
      {
          Debug.LogWarning("Potential pool leak detected!");
      }
  }
  ```
- Implement `ReturnAll()` on scene change

**Fallback:**
- Add circuit breaker (revert to direct instantiation)
- Increase pool size
- Force return all objects periodically

### Risk: Pool Too Small (Frequent Exhaustion)
**Symptom:** Console spam "Pool exhausted, creating new instance"

**Mitigation:**
- Monitor exhaustion frequency in profiler
- Increase pool size in Inspector
- Adjust pool sizes based on gameplay patterns

**Recommended Pool Sizes:**
- Thruster particles: 10 (1 per ship, ~10 ships max)
- Scan effects: 5 (rare usage)
- UI toasts: 3 (very rare)

---

## Testing Checklist

- [ ] ObjectPool<T> compiles without errors
- [ ] PoolManager initializes all pools on startup
- [ ] Thruster particles get from pool correctly
- [ ] Thruster particles return to pool on thrust end
- [ ] Pool exhaustion creates new instance (warning logged)
- [ ] Debug UI shows correct active/pooled counts
- [ ] Unity Profiler shows 80%+ GC reduction
- [ ] Frame rate stable (no GC stutters)
- [ ] Workflow A gravity lock still functional
- [ ] No memory leaks (active count doesn't grow indefinitely)

---

## Next Steps After Completion

1. **Expand Pooling:** Add pools for other frequent objects (projectiles in Phase 2+)
2. **Pool Prewarming:** Add option to prewarm pools with specific sizes
3. **Pool Analytics:** Track peak usage, exhaustion frequency
4. **Pool Cleanup:** Add `ReturnAll()` on scene transitions
5. **Advanced Features:** Implement pool trimming (reduce size if underutilized)
