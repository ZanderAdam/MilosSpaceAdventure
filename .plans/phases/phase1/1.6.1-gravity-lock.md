# Workflow A: Gravity Lock System
## Phase 1.6.1 - Mobile Enhancement

**State Machine:** PREP â†’ IMPL_SYSTEM â†’ IMPL_CONTROLLERS â†’ IMPL_VISUALS â†’ TEST â†’ COMPLETE
**Duration:** 1.5 days
**Priority:** HIGH
**Dependencies:** None (can start immediately)
**Blocks:** Workflow C (Object Pooling) cannot start until Task A4 completes

---

## Goal

Make it easier for kids (ages 5-8) to approach moving planets by automatically locking ship into planetary orbit.

---

## Specification

- Ship detects when within **2x planet visual radius**
- Smooth attraction force pulls ship toward planet center
- Ship follows planet's orbital path automatically
- Visual indicator shows which planet is locked
- Player can override with thrust input

---

## Task Breakdown

### A1: Analyze Existing Code (0.25d) - PREP State

**Objective:** Understand current physics implementation

**Actions:**
- Read: `Assets/_Project/Scripts/Player/PlayerShipController.cs`
- Read: `Assets/_Project/Scripts/StarSystem/CelestialBodyController.cs`
- Verify existing physics system compatibility
- Document current velocity/force application patterns

**Checkpoint:** âœ… Current system behavior documented

**Questions to Answer:**
- How does ship velocity currently work?
- How are forces applied to the ship?
- Does CelestialBodyController have physics references?
- Is there existing orbital mechanics code?

---

### A2: Implement GravityLockSystem.cs (0.5d) - IMPL_SYSTEM State

**Objective:** Create core gravity lock system

**File to Create:** `Assets/_Project/Scripts/Player/GravityLockSystem.cs`

**Implementation:**

```csharp
using UnityEngine;

public class GravityLockSystem : MonoBehaviour
{
    [Header("Settings")]
    [SerializeField] private float lockRadius = 2.0f; // Multiplier of planet visual radius
    [SerializeField] private float attractionForce = 5f;
    [SerializeField] private float lockStrength = 0.8f; // How strongly ship follows orbit

    [Header("Visual Feedback")]
    [SerializeField] private GameObject lockIndicatorPrefab;

    private CelestialBodyController _lockedPlanet;
    private GameObject _lockIndicator;
    private PlayerShipController _ship;

    public bool IsLocked => _lockedPlanet != null;
    public CelestialBodyController LockedPlanet => _lockedPlanet;

    private void Awake()
    {
        _ship = GetComponent<PlayerShipController>();
    }

    private void Update()
    {
        UpdateGravityLock();
    }

    private void UpdateGravityLock()
    {
        // Find nearest planet within lock radius
        var nearestPlanet = FindNearestPlanetInRange();

        if (nearestPlanet != null)
        {
            LockToPlanet(nearestPlanet);
        }
        else
        {
            ReleaseLock();
        }

        // Apply orbital following if locked
        if (_lockedPlanet != null)
        {
            ApplyOrbitalAttraction();
        }
    }

    private CelestialBodyController FindNearestPlanetInRange()
    {
        var allBodies = FindObjectsOfType<CelestialBodyController>();
        CelestialBodyController nearest = null;
        float minDist = float.MaxValue;

        foreach (var body in allBodies)
        {
            if (body.IsStar) continue; // Don't lock to stars

            float distance = Vector2.Distance(transform.position, body.transform.position);
            float lockDist = body.VisualRadius * lockRadius;

            if (distance < lockDist && distance < minDist)
            {
                nearest = body;
                minDist = distance;
            }
        }

        return nearest;
    }

    private void LockToPlanet(CelestialBodyController planet)
    {
        if (_lockedPlanet != planet)
        {
            _lockedPlanet = planet;
            ShowLockIndicator(planet);
        }
    }

    private void ReleaseLock()
    {
        if (_lockedPlanet != null)
        {
            _lockedPlanet = null;
            HideLockIndicator();
        }
    }

    private void ApplyOrbitalAttraction()
    {
        if (_lockedPlanet == null) return;

        // Calculate attraction toward planet center
        Vector2 toPlanet = (Vector2)_lockedPlanet.transform.position - (Vector2)transform.position;
        Vector2 attraction = toPlanet.normalized * attractionForce * Time.deltaTime;

        // Apply to ship velocity (if ship has public velocity access)
        _ship.ApplyExternalForce(attraction * lockStrength);

        // Optional: Match orbital velocity
        Vector2 orbitalVelocity = _lockedPlanet.GetOrbitalVelocity();
        _ship.ApplyExternalForce(orbitalVelocity * lockStrength * 0.5f);
    }

    private void ShowLockIndicator(CelestialBodyController planet)
    {
        if (_lockIndicator == null && lockIndicatorPrefab != null)
        {
            _lockIndicator = Instantiate(lockIndicatorPrefab, planet.transform);
        }
        else if (_lockIndicator != null)
        {
            _lockIndicator.transform.SetParent(planet.transform);
            _lockIndicator.transform.localPosition = Vector3.zero;
        }

        _lockIndicator?.SetActive(true);
    }

    private void HideLockIndicator()
    {
        if (_lockIndicator != null)
        {
            _lockIndicator.SetActive(false);
        }
    }
}
```

**Checkpoint:** âœ… System compiles without errors

**Transition to:** IMPL_CONTROLLERS State

---

### A3: Update CelestialBodyController.cs (0.25d) - IMPL_CONTROLLERS State

**Objective:** Add orbital velocity and visual radius properties

**File to Modify:** `Assets/_Project/Scripts/StarSystem/CelestialBodyController.cs`

**Add These Methods:**

```csharp
public float VisualRadius => spriteRenderer.bounds.extents.magnitude;

public Vector2 GetOrbitalVelocity()
{
    if (_data.IsStar) return Vector2.zero;

    // Calculate tangent velocity based on orbit
    float angleRad = _currentAngle * Mathf.Deg2Rad;
    float tangentAngle = angleRad + Mathf.PI / 2f;
    float speed = _data.orbitSpeed * _data.orbitDistance;

    return new Vector2(
        Mathf.Cos(tangentAngle),
        Mathf.Sin(tangentAngle)
    ) * speed;
}
```

**Checkpoint:** âœ… All celestial bodies report correct orbital velocity

**Notes:**
- Verify `spriteRenderer` is accessible (may need to cache in existing code)
- Test with different planet sizes
- Ensure stars return zero velocity (they don't orbit)

---

### A4: Update PlayerShipController.cs (0.25d) - IMPL_CONTROLLERS State

**Objective:** Add external force application method

ðŸ”“ **CRITICAL:** This task unblocks Workflow C (Object Pooling)

**File to Modify:** `Assets/_Project/Scripts/Player/PlayerShipController.cs`

**Add This Method:**

```csharp
public void ApplyExternalForce(Vector2 force)
{
    _velocity += force;
    if (_velocity.magnitude > maxSpeed)
        _velocity = _velocity.normalized * maxSpeed;
}
```

**Checkpoint:** âœ… External forces integrate with existing physics

**Notes:**
- Ensure velocity clamping respects `maxSpeed`
- Test that player thrust can override external forces
- Verify forces don't cause ship to spin uncontrollably

---

### A5: Create Lock Indicator Prefab (0.25d) - IMPL_VISUALS State

**Objective:** Create visual feedback for locked planets

**File to Create:** `Assets/_Project/Prefabs/PlanetLockIndicator.prefab`

**Specifications:**
- **Visual:** Pulsing ring or arrow around planet
- **Color:** Soft green/cyan (friendly, not alarming)
- **Scale:** 1.2x planet radius
- **Animation:** Gentle pulse (0.9x to 1.1x scale over 1 second)

**Implementation Steps:**
1. Create empty GameObject in scene
2. Add SpriteRenderer with ring/circle sprite
3. Set color to cyan (R:0, G:255, B:200, A:128)
4. Add simple scale animation:
   ```csharp
   // Optional Animation script
   void Update()
   {
       float pulse = 1f + 0.1f * Mathf.Sin(Time.time * 2f);
       transform.localScale = Vector3.one * pulse;
   }
   ```
5. Drag to Prefabs folder
6. Assign to GravityLockSystem's `lockIndicatorPrefab` field in Inspector

**Checkpoint:** âœ… Indicator visible in scene

---

### A6: Testing (0.25d) - TEST State

**Objective:** Validate all gravity lock functionality

**Test Cases:**

1. **Lock Detection**
   - Approach planet slowly â†’ lock should trigger at 2x radius
   - Fly past planet quickly â†’ lock should trigger/release smoothly
   - Test with small planets (moons) and large planets (Jupiter)

2. **Smooth Attraction**
   - Ship should smoothly pull toward planet center
   - No violent jerking or oscillation
   - Attraction strength should feel natural (not too weak or strong)

3. **Orbital Following**
   - Ship should begin to follow planet's orbital path
   - Orbital velocity should match planet's movement
   - Ship maintains stable distance from planet

4. **Indicator Display**
   - Indicator appears when lock engages
   - Indicator disappears when lock releases
   - Indicator stays centered on locked planet
   - Indicator scales with planet size (optional enhancement)

5. **Player Override**
   - Player thrust input should override lock attraction
   - Player can escape locked planet with sufficient thrust
   - Lock releases when ship moves beyond 2x radius

6. **All Planet Sizes**
   - Test with smallest moon
   - Test with medium planet (Earth)
   - Test with largest planet (Jupiter/Saturn)
   - Lock radius should scale appropriately

**Quality Gate:** âœ… All 6 test cases must pass

**Kid Testing (Ages 5-8):**
- Can they reach planets without frustration?
- Do they understand when lock is active?
- Is the attraction force helpful (not annoying)?

**Checkpoint:** âœ… Kid testing validates ease of use

**Transition to:** COMPLETE State

---

## Integration Points

### With Workflow B (Autosave)
- **Issue:** Lock state (which planet is locked) not persisted
- **Enhancement:** Consider adding `lockedPlanetId` to SaveData
- **Validation:** Lock to planet â†’ save â†’ quit â†’ reload â†’ verify lock restored

### With Workflow C (Object Pooling)
- **File:** `PlayerShipController.cs`
- **Issue:** Task C4 modifies thrust particle logic; may affect A4's `ApplyExternalForce`
- **Mitigation:** Test gravity lock after pooling integration
- **Validation:** Run A6 tests again after C4 complete

---

## Risk Mitigation

### Risk: Gravity Lock Physics Instability
**Symptom:** Ship oscillates or flies off uncontrollably

**Mitigation:**
- Reduce `attractionForce` (start with 5, adjust down if needed)
- Keep `lockStrength` < 1.0 (default 0.8)
- Add velocity clamping in `ApplyOrbitalAttraction()`:
  ```csharp
  Vector2 clampedAttraction = Vector2.ClampMagnitude(attraction, 10f);
  _ship.ApplyExternalForce(clampedAttraction * lockStrength);
  ```

**Fallback:**
- Make gravity lock optional (add toggle in settings)
- Disable orbital following, keep only center attraction

---

## Completion Criteria

- âœ… Ship locks at 2x planet radius
- âœ… Smooth orbital attraction active
- âœ… Visual indicator functional
- âœ… Player can override with thrust
- âœ… All test cases pass
- âœ… Kid testing validates helpfulness
- âœ… No regressions in existing ship controls

---

## Files Modified/Created

**Created (2):**
- `Assets/_Project/Scripts/Player/GravityLockSystem.cs`
- `Assets/_Project/Prefabs/PlanetLockIndicator.prefab`

**Modified (2):**
- `Assets/_Project/Scripts/StarSystem/CelestialBodyController.cs`
- `Assets/_Project/Scripts/Player/PlayerShipController.cs`

---

## State Transitions

```
NOT_STARTED
    â†“
[A1] PREP (analyze code)
    â†“
[A2] IMPL_SYSTEM (create GravityLockSystem)
    â†“
[A3-A4] IMPL_CONTROLLERS (update celestial & ship)
    â†“
[A5] IMPL_VISUALS (create indicator)
    â†“
[A6] TEST (validate all functionality)
    â†“
COMPLETE (ready for integration)
```

---

## Next Steps After Completion

1. **Unblock Workflow C:** Object Pooling can now start (depends on A4)
2. **Consider Enhancement:** Add lock state to SaveData for persistence
3. **Monitor:** Watch for physics issues in playtesting
4. **Optional:** Add sound effect when lock engages/releases
