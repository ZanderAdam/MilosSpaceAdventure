# Phase 1.6: Mobile Enhancements & Performance
## Milo's Space Adventure - Development Plan

**Duration:** 3-4 days (2-3 days for high priority only)
**Trigger:** After Phase 1 core features complete
**Goal:** Add mobile-critical features identified in project plan review

---

## Workflow Orchestration Overview

This phase uses a **hybrid sequential-parallel workflow architecture** for efficient execution.

### Workflow Structure

```
Day 1-2:  [A: Gravity Lock] â†â†’ [B: Autosave] â†â†’ [D: Sprite Atlas]
             â†“
Day 2-3:  [C: Object Pooling] (depends on A)
             â†“
Day 3-4:  [E: Integration Testing]
```

**Priority Tiers:**
- **HIGH PRIORITY:** Workflows A (Gravity Lock) + B (Autosave) - Critical for mobile UX
- **MEDIUM PRIORITY:** Workflows C (Object Pooling) + D (Sprite Atlas) - Performance optimization

**Solo Developer Path:** Focus on A + B first (2-3 days), defer C + D for later phase

---

## Overview

Phase 1.6 addresses 4 critical enhancements for mobile + kid-friendly gameplay:
1. **Gravity Lock** (Workflow A) - Help ages 5-8 target moving planets
2. **Autosave** (Workflow B) - Support 15-30 min mobile sessions
3. **Object Pooling** (Workflow C) - Prevent mobile GC spikes
4. **Sprite Atlas** (Workflow D) - Achieve 30 FPS on mobile

**Why Phase 1.6?**
- These features were in the project plan but missed in phase1-plan.md
- Critical for mobile experience (not "nice to have")
- Should be implemented before Phase 2 to inform gameplay design

**Workflow Dependencies:**
- Workflow C (Object Pooling) BLOCKED until Workflow A Task A4 completes
- Workflow E (Integration) requires all workflows complete
- Workflows A, B, D can run in parallel

---

## Day 1-2: Gravity Lock Mechanic (Workflow A)

**State Machine:** PREP â†’ IMPL_SYSTEM â†’ IMPL_CONTROLLERS â†’ IMPL_VISUALS â†’ TEST â†’ COMPLETE
**Duration:** 1.5 days
**Priority:** HIGH
**Dependencies:** None (can start immediately)
**Blocks:** Workflow C cannot start until Task A4 completes

### Goal
Make it easier for kids (ages 5-8) to approach moving planets by automatically locking ship into planetary orbit.

### Specification
- Ship detects when within **2x planet visual radius**
- Smooth attraction force pulls ship toward planet center
- Ship follows planet's orbital path automatically
- Visual indicator shows which planet is locked
- Player can override with thrust input

### Workflow A Task Breakdown

**A1: Analyze Existing Code** (0.25d)
- Read: `PlayerShipController.cs`, `CelestialBodyController.cs`
- Verify existing physics system compatibility
- Document current velocity/force application patterns
- **Checkpoint:** Current system behavior documented

**A2: Implement GravityLockSystem.cs** (0.5d)
- Create `Assets/_Project/Scripts/Player/GravityLockSystem.cs`
- Core methods: `UpdateGravityLock()`, `FindNearestPlanetInRange()`, `ApplyOrbitalAttraction()`
- **Checkpoint:** System compiles without errors

**A3: Update CelestialBodyController.cs** (0.25d)
- Add `VisualRadius` property
- Add `GetOrbitalVelocity()` method
- **Checkpoint:** All celestial bodies report correct orbital velocity

**A4: Update PlayerShipController.cs** (0.25d) ðŸ”“
- Add `ApplyExternalForce(Vector2)` method
- **CRITICAL:** This unblocks Workflow C (Object Pooling)
- **Checkpoint:** External forces integrate with existing physics

**A5: Create Lock Indicator Prefab** (0.25d)
- Create `Assets/_Project/Prefabs/PlanetLockIndicator.prefab`
- Visual: pulsing ring, soft green/cyan, 1.2x planet radius
- **Checkpoint:** Indicator visible in scene

**A6: Testing** (0.25d)
- Test cases: lock detection, smooth attraction, orbital following, indicator display, player override, all planet sizes
- **Quality Gate:** All 6 test cases must pass
- **Checkpoint:** Kid testing (ages 5-8) validates ease of use

### Implementation

**GravityLockSystem.cs:**
```csharp
using UnityEngine;

public class GravityLockSystem : MonoBehaviour
{
    [Header("Settings")]
    [SerializeField] private float lockRadius = 2.0f; // Multiplier of planet visual radius
    [SerializeField] private float attractionForce = 5f;
    [SerializeField] private float lockStrength = 0.8f; // How strongly ship follows orbit

    [Header("Visual Feedback")]
    [SerializeField] private GameObject lockIndicatorPrefab;

    private CelestialBodyController _lockedPlanet;
    private GameObject _lockIndicator;
    private PlayerShipController _ship;

    public bool IsLocked => _lockedPlanet != null;
    public CelestialBodyController LockedPlanet => _lockedPlanet;

    private void Awake()
    {
        _ship = GetComponent<PlayerShipController>();
    }

    private void Update()
    {
        UpdateGravityLock();
    }

    private void UpdateGravityLock()
    {
        // Find nearest planet within lock radius
        var nearestPlanet = FindNearestPlanetInRange();

        if (nearestPlanet != null)
        {
            LockToPlanet(nearestPlanet);
        }
        else
        {
            ReleaseLock();
        }

        // Apply orbital following if locked
        if (_lockedPlanet != null)
        {
            ApplyOrbitalAttraction();
        }
    }

    private CelestialBodyController FindNearestPlanetInRange()
    {
        var allBodies = FindObjectsOfType<CelestialBodyController>();
        CelestialBodyController nearest = null;
        float minDist = float.MaxValue;

        foreach (var body in allBodies)
        {
            if (body.IsStar) continue; // Don't lock to stars

            float distance = Vector2.Distance(transform.position, body.transform.position);
            float lockDist = body.VisualRadius * lockRadius;

            if (distance < lockDist && distance < minDist)
            {
                nearest = body;
                minDist = distance;
            }
        }

        return nearest;
    }

    private void LockToPlanet(CelestialBodyController planet)
    {
        if (_lockedPlanet != planet)
        {
            _lockedPlanet = planet;
            ShowLockIndicator(planet);
        }
    }

    private void ReleaseLock()
    {
        if (_lockedPlanet != null)
        {
            _lockedPlanet = null;
            HideLockIndicator();
        }
    }

    private void ApplyOrbitalAttraction()
    {
        if (_lockedPlanet == null) return;

        // Calculate attraction toward planet center
        Vector2 toPlanet = (Vector2)_lockedPlanet.transform.position - (Vector2)transform.position;
        Vector2 attraction = toPlanet.normalized * attractionForce * Time.deltaTime;

        // Apply to ship velocity (if ship has public velocity access)
        _ship.ApplyExternalForce(attraction * lockStrength);

        // Optional: Match orbital velocity
        Vector2 orbitalVelocity = _lockedPlanet.GetOrbitalVelocity();
        _ship.ApplyExternalForce(orbitalVelocity * lockStrength * 0.5f);
    }

    private void ShowLockIndicator(CelestialBodyController planet)
    {
        if (_lockIndicator == null && lockIndicatorPrefab != null)
        {
            _lockIndicator = Instantiate(lockIndicatorPrefab, planet.transform);
        }
        else if (_lockIndicator != null)
        {
            _lockIndicator.transform.SetParent(planet.transform);
            _lockIndicator.transform.localPosition = Vector3.zero;
        }

        _lockIndicator?.SetActive(true);
    }

    private void HideLockIndicator()
    {
        if (_lockIndicator != null)
        {
            _lockIndicator.SetActive(false);
        }
    }
}
```

**Updates Required:**

1. **CelestialBodyController.cs** - Add:
```csharp
public float VisualRadius => spriteRenderer.bounds.extents.magnitude;

public Vector2 GetOrbitalVelocity()
{
    if (_data.IsStar) return Vector2.zero;

    // Calculate tangent velocity based on orbit
    float angleRad = _currentAngle * Mathf.Deg2Rad;
    float tangentAngle = angleRad + Mathf.PI / 2f;
    float speed = _data.orbitSpeed * _data.orbitDistance;

    return new Vector2(
        Mathf.Cos(tangentAngle),
        Mathf.Sin(tangentAngle)
    ) * speed;
}
```

2. **PlayerShipController.cs** - Add:
```csharp
public void ApplyExternalForce(Vector2 force)
{
    _velocity += force;
    if (_velocity.magnitude > maxSpeed)
        _velocity = _velocity.normalized * maxSpeed;
}
```

3. **Lock Indicator Prefab:**
   - Create `Assets/_Project/Prefabs/PlanetLockIndicator.prefab`
   - Simple sprite: pulsing ring or arrow around planet
   - Color: soft green/cyan (friendly, not alarming)
   - Scale: 1.2x planet radius

### Testing
- [ ] Ship locks when within 2x radius
- [ ] Smooth attraction toward planet center
- [ ] Ship follows orbital path
- [ ] Visual indicator appears/disappears correctly
- [ ] Player can still thrust away from planet
- [ ] Works with all planet sizes

### Deliverables
- [ ] GravityLockSystem.cs
- [ ] Update CelestialBodyController.cs
- [ ] Update PlayerShipController.cs
- [ ] PlanetLockIndicator prefab
- [ ] Manual test with kid (ages 5-8) - can they reach planets easily?

---

## Day 2-3: Autosave System (Workflow B)

**State Machine:** ANALYZE â†’ EXTEND_SAVE â†’ EXTEND_DATA â†’ IMPL_BOOT â†’ TEST_MOBILE â†’ COMPLETE
**Duration:** 1.5 days
**Priority:** HIGH
**Dependencies:** None (can run in parallel with Workflow A)
**Blocks:** None

### Goal
Support mobile 15-30 min play sessions with automatic save/resume.

### Current State
Phase 1 has manual save/load (SaveManager.cs). Need to make it automatic.

### Specification
- Auto-save triggers:
  - Every planet scanned (Phase 2+)
  - Every 5 minutes of idle gameplay
  - OnApplicationPause (mobile backgrounding)
  - OnApplicationQuit (clean shutdown)
- Resume from last save on app reopen
- Persistent across sessions
- No "Save/Load" buttons visible to player

### Workflow B Task Breakdown

**B1: Analyze Current SaveManager** (0.25d)
- Read: `SaveManager.cs`, `SaveData.cs`
- Document current save/load flow
- **Checkpoint:** Current system behavior documented

**B2: Implement Auto-Save Logic** (0.5d)
- Update `SaveManager.cs`: add auto-save interval timer, `OnApplicationPause()`, `OnApplicationQuit()`, `AutoSave(string reason)`
- Add events: `OnSaveCompleted`, `OnLoadCompleted`
- **Checkpoint:** Auto-save triggers every 5 minutes

**B3: Extend SaveData** (0.25d)
- Add `lastSaveTime` (ISO 8601)
- Add ship position/rotation fields
- Add placeholders for Phase 2+ data
- **Checkpoint:** SaveData serializes/deserializes correctly

**B4: Create BootController** (0.25d)
- Create `Assets/_Project/Scripts/Save/BootController.cs`
- Auto-load on startup if save exists
- **Checkpoint:** Boot sequence loads save data

**B5: Mobile Testing** (0.25d)
- Test OnApplicationPause (background app) - Unity Editor simulation if no device
- Test OnApplicationQuit (force close)
- Test resume from save
- **Quality Gate:** No data loss on crash/background

### Implementation

**Update SaveManager.cs:**
```csharp
using UnityEngine;
using System.IO;
using System;

public class SaveManager : MonoBehaviour
{
    public static SaveManager Instance { get; private set; }

    [Header("Auto-Save Settings")]
    [SerializeField] private float autoSaveInterval = 300f; // 5 minutes
    [SerializeField] private bool enableAutoSave = true;

    private string SavePath => Path.Combine(Application.persistentDataPath, "save.json");
    private float _timeSinceLastSave;

    public event Action OnSaveCompleted;
    public event Action<SaveData> OnLoadCompleted;

    private void Awake()
    {
        if (Instance != null) { Destroy(gameObject); return; }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    private void Update()
    {
        if (!enableAutoSave) return;

        _timeSinceLastSave += Time.deltaTime;

        if (_timeSinceLastSave >= autoSaveInterval)
        {
            AutoSave("Timed auto-save");
        }
    }

    private void OnApplicationPause(bool pauseStatus)
    {
        if (pauseStatus && enableAutoSave)
        {
            AutoSave("App paused");
        }
    }

    private void OnApplicationQuit()
    {
        if (enableAutoSave)
        {
            AutoSave("App quit");
        }
    }

    public void AutoSave(string reason)
    {
        var data = GatherSaveData();
        Save(data);
        _timeSinceLastSave = 0f;

        Debug.Log($"Auto-saved: {reason}");
    }

    private SaveData GatherSaveData()
    {
        var data = new SaveData();

        // Gather from various systems
        var ship = FindObjectOfType<PlayerShipController>();
        if (ship != null)
        {
            data.shipX = ship.transform.position.x;
            data.shipY = ship.transform.position.y;
            data.shipRotation = ship.transform.eulerAngles.z;
        }

        // TODO Phase 2+: Add scanned planets
        // TODO Phase 3+: Add rescued stuffies

        data.lastSaveTime = DateTime.Now.ToString("o");

        return data;
    }

    public void Save(SaveData data)
    {
        try
        {
            string json = JsonUtility.ToJson(data, true);
            File.WriteAllText(SavePath, json);
            OnSaveCompleted?.Invoke();
        }
        catch (Exception e)
        {
            Debug.LogError($"Save failed: {e.Message}");
        }
    }

    public SaveData Load()
    {
        if (!File.Exists(SavePath))
        {
            Debug.Log("No save file found");
            return null;
        }

        try
        {
            string json = File.ReadAllText(SavePath);
            var data = JsonUtility.FromJson<SaveData>(json);
            OnLoadCompleted?.Invoke(data);
            return data;
        }
        catch (Exception e)
        {
            Debug.LogError($"Load failed: {e.Message}");
            return null;
        }
    }

    public void LoadAndApply()
    {
        var data = Load();
        if (data != null)
        {
            ApplySaveData(data);
        }
    }

    private void ApplySaveData(SaveData data)
    {
        var ship = FindObjectOfType<PlayerShipController>();
        if (ship != null)
        {
            ship.transform.position = new Vector3(data.shipX, data.shipY, 0);
            ship.transform.rotation = Quaternion.Euler(0, 0, data.shipRotation);
        }

        Debug.Log($"Loaded save from: {data.lastSaveTime}");
    }

    public void DeleteSave()
    {
        if (File.Exists(SavePath)) File.Delete(SavePath);
    }

    public bool HasSaveData()
    {
        return File.Exists(SavePath);
    }
}
```

**Update SaveData.cs:**
```csharp
[System.Serializable]
public class SaveData
{
    public string currentSystemId;
    public float shipX;
    public float shipY;
    public float shipRotation;

    public string lastSaveTime; // ISO 8601 format

    // Phase 2+
    // public List<string> scannedPlanetIds;

    // Phase 3+
    // public List<string> rescuedStuffyIds;
    // public List<string> unlockedAbilities;
}
```

**Boot Flow Update:**

Create **BootController.cs**:
```csharp
using UnityEngine;

public class BootController : MonoBehaviour
{
    private void Start()
    {
        // Auto-load on startup
        if (SaveManager.Instance.HasSaveData())
        {
            SaveManager.Instance.LoadAndApply();
            Debug.Log("Resumed from last session");
        }
        else
        {
            Debug.Log("New game started");
        }
    }
}
```

### Testing
- [ ] Auto-save every 5 minutes
- [ ] Save on mobile background (OnApplicationPause)
- [ ] Save on quit
- [ ] Resume from save on app reopen
- [ ] No data loss when app crashes
- [ ] SaveData persists across Unity restarts

### Deliverables
- [ ] Update SaveManager.cs with auto-save
- [ ] Update SaveData.cs with timestamp
- [ ] Create BootController.cs
- [ ] Remove manual Save/Load UI buttons (or hide in debug menu)
- [ ] Test on actual mobile device

---

## Day 3: Object Pooling (Workflow C)

**State Machine:** ANALYZE â†’ IMPL_POOL â†’ IMPL_MANAGER â†’ INTEGRATE â†’ PROFILE â†’ COMPLETE
**Duration:** 1 day
**Priority:** MEDIUM
**Dependencies:** ðŸ”’ BLOCKED until Workflow A Task A4 completes (needs `ApplyExternalForce`)
**Blocks:** None

### Goal
Prevent mobile GC spikes by reusing particles and UI elements.

### Specification
- Generic ObjectPool<T> for any poolable type
- Pre-populate pools to avoid instantiation during gameplay
- Pool candidates: thruster particles, UI popups, scan effects
- Target: Reduce GC allocations by 80%+

### Workflow C Task Breakdown

**C1: Analyze Pooling Candidates** (0.25d)
- Identify: thruster particles, planet glow effects, UI toasts
- Document instantiation patterns
- **Checkpoint:** Pool sizes estimated (10/5/3 instances)

**C2: Implement ObjectPool<T>** (0.25d)
- Create `Assets/_Project/Scripts/Core/ObjectPool.cs`
- Generic pool with Get/Return/ReturnAll
- Pre-population support
- **Checkpoint:** Generic pool class compiles

**C3: Implement PoolManager Singleton** (0.25d)
- Create `Assets/_Project/Scripts/Core/PoolManager.cs`
- Pools: thruster particles, scan effects
- **Checkpoint:** Pools initialize on startup

**C4: Update PlayerShipController** (0.25d)
- Replace direct particle instantiation with pooling
- Methods: `OnThrustStart()`, `OnThrustStop()`
- **INTEGRATION POINT:** Verify gravity lock still works after pooling
- **Checkpoint:** Thruster particles pool correctly

**C5: Performance Profiling** (0.25d)
- Unity Profiler: measure GC allocations before/after
- **Quality Gate:** 80%+ GC reduction (100KBâ†’20KB per frame)
- Test in Unity Editor (mobile device if available)
- **Checkpoint:** Performance targets met

### Implementation

**ObjectPool.cs:**
```csharp
using System.Collections.Generic;
using UnityEngine;

public class ObjectPool<T> where T : Component
{
    private readonly T _prefab;
    private readonly Transform _parent;
    private readonly Queue<T> _pool = new Queue<T>();
    private readonly HashSet<T> _active = new HashSet<T>();

    public ObjectPool(T prefab, int initialSize, Transform parent = null)
    {
        _prefab = prefab;
        _parent = parent;

        // Pre-populate pool
        for (int i = 0; i < initialSize; i++)
        {
            var obj = Object.Instantiate(_prefab, _parent);
            obj.gameObject.SetActive(false);
            _pool.Enqueue(obj);
        }
    }

    public T Get()
    {
        T obj;

        if (_pool.Count > 0)
        {
            obj = _pool.Dequeue();
        }
        else
        {
            // Pool exhausted - create new instance
            obj = Object.Instantiate(_prefab, _parent);
            Debug.LogWarning($"Pool exhausted for {typeof(T).Name}, creating new instance");
        }

        obj.gameObject.SetActive(true);
        _active.Add(obj);
        return obj;
    }

    public void Return(T obj)
    {
        if (!_active.Contains(obj))
        {
            Debug.LogWarning($"Returning object not from this pool: {obj.name}");
            return;
        }

        obj.gameObject.SetActive(false);
        _active.Remove(obj);
        _pool.Enqueue(obj);
    }

    public void ReturnAll()
    {
        foreach (var obj in _active)
        {
            obj.gameObject.SetActive(false);
            _pool.Enqueue(obj);
        }
        _active.Clear();
    }

    public int ActiveCount => _active.Count;
    public int PooledCount => _pool.Count;
}
```

**PoolManager.cs (Singleton):**
```csharp
using UnityEngine;

public class PoolManager : MonoBehaviour
{
    public static PoolManager Instance { get; private set; }

    [Header("Prefabs")]
    [SerializeField] private ParticleSystem thrusterParticlePrefab;
    [SerializeField] private GameObject scanEffectPrefab;

    [Header("Pool Sizes")]
    [SerializeField] private int thrusterParticlePoolSize = 10;
    [SerializeField] private int scanEffectPoolSize = 5;

    private ObjectPool<ParticleSystem> _thrusterParticlePool;
    private ObjectPool<GameObject> _scanEffectPool;

    private void Awake()
    {
        if (Instance != null) { Destroy(gameObject); return; }
        Instance = this;
        DontDestroyOnLoad(gameObject);

        InitializePools();
    }

    private void InitializePools()
    {
        if (thrusterParticlePrefab != null)
        {
            _thrusterParticlePool = new ObjectPool<ParticleSystem>(
                thrusterParticlePrefab,
                thrusterParticlePoolSize,
                transform
            );
        }

        // Add more pools as needed
    }

    public ParticleSystem GetThrusterParticle()
    {
        return _thrusterParticlePool?.Get();
    }

    public void ReturnThrusterParticle(ParticleSystem ps)
    {
        _thrusterParticlePool?.Return(ps);
    }
}
```

**Update PlayerShipController.cs:**
```csharp
// Replace direct ParticleSystem instantiation with pooling
private ParticleSystem _currentThrusterParticle;

private void OnThrustStart()
{
    if (_currentThrusterParticle == null)
    {
        _currentThrusterParticle = PoolManager.Instance.GetThrusterParticle();
        _currentThrusterParticle.transform.SetParent(transform);
        _currentThrusterParticle.transform.localPosition = Vector3.zero;
    }
    _currentThrusterParticle.Play();
}

private void OnThrustStop()
{
    if (_currentThrusterParticle != null)
    {
        _currentThrusterParticle.Stop();
        PoolManager.Instance.ReturnThrusterParticle(_currentThrusterParticle);
        _currentThrusterParticle = null;
    }
}
```

### Pool Candidates for Phase 1
1. **Thruster particles** (10 instances)
2. **Planet glow effects** (5 instances)
3. **UI toast notifications** (3 instances)

### Testing
- [ ] Pools pre-populated on startup
- [ ] Get/Return cycle works correctly
- [ ] Profiler shows reduced GC allocations
- [ ] Pool exhaustion handled gracefully
- [ ] Mobile frame rate stable (30 FPS+)

### Deliverables
- [ ] ObjectPool<T> generic class
- [ ] PoolManager singleton
- [ ] Update PlayerShipController to use pooling
- [ ] Profiler comparison: before/after GC metrics
- [ ] Test on mobile device

---

## Day 4: Sprite Atlas (Workflow D)

**State Machine:** CREATE â†’ CONFIGURE â†’ POPULATE â†’ INTEGRATE â†’ VALIDATE â†’ COMPLETE
**Duration:** 0.5 days
**Priority:** MEDIUM
**Dependencies:** None (can run in parallel with A, B)
**Blocks:** None

### Goal
Reduce draw calls from 100+ to ~5 for 30 FPS mobile target.

### Specification
- Create `CelestialsAtlas.spriteatlas`
- Include: Sun, all planets, moons, ship, particles
- Update StarSystemLoader to use atlas sprites
- Enable atlas in build settings

### Workflow D Task Breakdown

**D1: Create Sprite Atlas** (0.1d)
- Create `Assets/_Project/Art/Atlases/CelestialsAtlas.spriteatlas`
- Type: Master, Include in Build: âœ…
- **Checkpoint:** Atlas asset exists

**D2: Configure Atlas Settings** (0.1d)
- Max Size: 2048x2048
- Android: RGBA Compressed ETC2 8 bits
- iOS: RGBA Compressed PVRTC 4 bits
- **Checkpoint:** Platform settings configured

**D3: Populate Atlas** (0.1d)
- Add: `StarSystems/Sol/` sprites, `Art/Ship/`, `Art/Particles/`
- Pack preview: verify all sprites visible
- **Checkpoint:** All sprites packed, atlas size < 2048x2048

**D4: Update StarSystemLoader** (0.15d)
- Add `SpriteAtlas celestialsAtlas` field
- Update `LoadSpriteAsync()`: try atlas first, fallback to StreamingAssets
- **Checkpoint:** Sprites load from atlas

**D5: Performance Validation** (0.15d)
- Unity Profiler: measure draw calls before/after
- Stats window: verify batch count
- **Quality Gate:** Draw calls < 10 (from 100+)
- **Quality Gate:** 30 FPS in Unity Editor (mobile if available)
- **Checkpoint:** Performance targets met

### Implementation Steps

**1. Create Sprite Atlas:**

1. Right-click in Unity: `Create â†’ 2D â†’ Sprite Atlas`
2. Name: `CelestialsAtlas`
3. Location: `Assets/_Project/Art/Atlases/CelestialsAtlas.spriteatlas`

**2. Configure Atlas Settings:**
```
Inspector Settings:
- Type: Master
- Include in Build: âœ… Checked
- Allow Rotation: âœ… Checked (better packing)
- Tight Packing: âœ… Checked
- Padding: 2

Platform Settings (Android):
- Max Texture Size: 2048
- Format: RGBA Compressed ETC2 8 bits

Platform Settings (iOS):
- Max Texture Size: 2048
- Format: RGBA Compressed PVRTC 4 bits
```

**3. Add Objects to Atlas:**

Drag folders into "Objects for Packing":
- `Assets/_Project/Content/StarSystems/Sol/` (all celestial sprites)
- `Assets/_Project/Art/Ship/` (ship sprite)
- `Assets/_Project/Art/Particles/` (particle textures)

**4. Update StarSystemLoader.cs:**

```csharp
using UnityEngine;
using UnityEngine.U2D;

public class StarSystemLoader : MonoBehaviour
{
    [Header("Sprite Atlas")]
    [SerializeField] private SpriteAtlas celestialsAtlas;

    private IEnumerator LoadSpriteAsync(string systemId, string filename)
    {
        if (_loadedSprites.ContainsKey(filename))
            yield break;

        // Try atlas first
        if (celestialsAtlas != null)
        {
            string spriteName = Path.GetFileNameWithoutExtension(filename);
            Sprite sprite = celestialsAtlas.GetSprite(spriteName);

            if (sprite != null)
            {
                _loadedSprites[filename] = sprite;
                yield break; // Found in atlas, done
            }
        }

        // Fallback: Load from StreamingAssets (existing code)
        string path = $"{Application.streamingAssetsPath}/Systems/{systemId}/{filename}";
        // ... rest of existing code ...
    }
}
```

**5. Assign Atlas Reference:**
- Select StarSystemLoader GameObject in scene
- Drag `CelestialsAtlas` into "Celestials Atlas" field

**6. Verify Atlas Packing:**
- Select CelestialsAtlas in Project
- Click "Pack Preview" button
- Verify all sprites visible in preview
- Check atlas size (should be < 2048x2048)

### Build Settings

Enable Sprite Atlas in Project Settings:
1. Edit â†’ Project Settings â†’ Editor
2. Sprite Packer â†’ Mode: **"Always Enabled"**

### Performance Validation

**Before (no atlas):**
- Draw Calls: ~100+ (one per celestial sprite)
- Texture Memory: ~50 MB (multiple small textures)
- FPS (mobile): ~20-25

**After (with atlas):**
- Draw Calls: ~5-10 (batched by atlas)
- Texture Memory: ~10 MB (single compressed atlas)
- FPS (mobile): ~30+ âœ…

**Validation Tools:**
- Unity Profiler â†’ Rendering â†’ SetPass Calls (should drop significantly)
- Stats window (top-right in Game view): Batches count

### Testing
- [ ] Atlas packs all celestial sprites
- [ ] Sprites load from atlas (not StreamingAssets)
- [ ] Draw calls reduced to < 10
- [ ] Visual quality unchanged
- [ ] Mobile build: 30 FPS achieved
- [ ] Build size impact minimal (< 5 MB increase)

### Deliverables
- [ ] CelestialsAtlas.spriteatlas created
- [ ] Update StarSystemLoader.cs with atlas support
- [ ] Sprite Packer enabled in project settings
- [ ] Performance profiler comparison (before/after)
- [ ] Test on actual mobile device

---

## Phase 1.6 Complete Checklist

### Gravity Lock âœ…
- [ ] GravityLockSystem.cs implemented
- [ ] CelestialBodyController extended (VisualRadius, GetOrbitalVelocity)
- [ ] PlayerShipController extended (ApplyExternalForce)
- [ ] Lock indicator prefab created
- [ ] Tested with kid (ages 5-8) - planets easier to reach

### Autosave âœ…
- [ ] SaveManager auto-save implemented
- [ ] OnApplicationPause/Quit hooks working
- [ ] BootController auto-loads on startup
- [ ] SaveData includes timestamp
- [ ] Tested on mobile device - resume works

### Object Pooling âœ…
- [ ] ObjectPool<T> generic class created
- [ ] PoolManager singleton created
- [ ] PlayerShipController uses pooling
- [ ] GC allocations reduced (profiler verified)
- [ ] Mobile frame rate stable

### Sprite Atlas âœ…
- [ ] CelestialsAtlas.spriteatlas created
- [ ] All celestial sprites packed
- [ ] StarSystemLoader uses atlas
- [ ] Draw calls reduced to < 10
- [ ] 30 FPS achieved on mobile

### Testing âœ…
- [ ] All features tested individually
- [ ] Integration test: all 4 features work together
- [ ] Mobile device test: performance targets met
- [ ] No regressions in Phase 1 core features

---

## Workflow Orchestration Details

### Execution Strategy

**Solo Developer (Sequential with Interleaving):**
```
Day 1:    Workflow A (start) â†’ Workflow B (start)
Day 2:    Workflow A (finish) â†’ Workflow C (start) â†’ Workflow D
Day 3:    Workflow B (finish) â†’ Workflow C (finish)
Day 4:    Workflow E (integration testing)
```

**3 Developers (Maximum Parallelization):**
```
Day 1:    Dev1: Workflow A | Dev2: Workflow B | Dev3: Workflow D
Day 2:    Dev1: Workflow C | Dev2: Workflow B | Dev3: (assist)
Day 3:    All: Workflow E (integration testing)
```

### State Management & Progress Tracking

**Recommended State File:** `.plans/phases/phase1/1.6-progress.json`

```json
{
  "phase": "1.6",
  "started": "2025-11-29",
  "workflows": {
    "A": { "state": "IN_PROGRESS", "completedTasks": ["A1", "A2"], "blockers": [] },
    "B": { "state": "IN_PROGRESS", "completedTasks": ["B1"], "blockers": [] },
    "C": { "state": "BLOCKED", "completedTasks": [], "blockers": ["Waiting for A4"] },
    "D": { "state": "IN_PROGRESS", "completedTasks": ["D1"], "blockers": [] },
    "E": { "state": "NOT_STARTED", "completedTasks": [], "blockers": ["Waiting for A,B,C,D"] }
  },
  "progressPercent": 15,
  "estimatedCompletion": "2025-12-02"
}
```

**Workflow State Transitions:**
- NOT_STARTED â†’ IN_PROGRESS â†’ COMPLETE
- BLOCKED â†’ IN_PROGRESS (when dependencies met)
- COMPLETE â†’ ROLLBACK (if issues found)

### Error Handling & Rollback Strategy

**3-Level Rollback System:**

**Level 1: Task Rollback**
- Scope: Single file changes
- Action: `git checkout -- <file>`
- Trigger: Task fails quality gate
- Example: If A2 has bugs, revert `GravityLockSystem.cs`

**Level 2: Workflow Rollback**
- Scope: Entire feature
- Action: Feature branch reset or stash
- Trigger: Multiple task failures or integration issues
- Example: If Workflow C causes crashes, revert all pooling changes

**Level 3: Phase Rollback**
- Scope: Full Phase 1.6
- Action: Return to Phase 1 clean state
- Trigger: Critical blocker or performance targets not achievable
- Example: If mobile FPS cannot reach 30, defer Phase 1.6

### Circuit Breakers

**Autosave Circuit Breaker:**
- Trigger: 3 consecutive save failures
- Action: Disable auto-save, log error, notify user
- Recovery: Manual re-enable after fix

**Object Pool Circuit Breaker:**
- Trigger: Pool exhaustion >10x in 1 minute
- Action: Revert to direct instantiation
- Recovery: Increase pool size or investigate leak

### Risk Assessment & Mitigation

**High Risks:**

1. **Gravity Lock Physics Instability**
   - Symptom: Ship oscillates or flies off uncontrollably
   - Mitigation: Force clamping, lockStrength < 1.0, max velocity limits
   - Fallback: Make gravity lock optional (toggle in settings)

2. **Autosave File Corruption**
   - Symptom: Save file unreadable, data loss
   - Mitigation: Atomic writes (temp file â†’ rename), CRC validation, backup previous save
   - Fallback: Delete corrupt save, start fresh (better than crash)

3. **Object Pooling Memory Leaks**
   - Symptom: Memory grows over time, pool never returns objects
   - Mitigation: Pool size limits, leak detection (active count monitoring)
   - Fallback: Revert to direct instantiation

4. **Sprite Atlas Doesn't Reduce Draw Calls**
   - Symptom: Draw calls still high (>50) despite atlas
   - Mitigation: Verify atlas enabled in build, check all sprites using atlas, disable dynamic batching
   - Fallback: Use smaller atlases per system type

### Integration Points

**Critical Integrations:**

**1. Gravity Lock â†” Object Pooling**
- File: `PlayerShipController.cs`
- Issue: Task C4 modifies thrust particle logic; may affect A4's `ApplyExternalForce`
- Mitigation: Test gravity lock after pooling integration
- Validation: Run A6 tests again after C4 complete

**2. Autosave â†” Gravity Lock**
- Files: `SaveManager.cs`, `SaveData.cs`, `GravityLockSystem.cs`
- Issue: Lock state (which planet is locked) not persisted
- Enhancement: Consider adding `lockedPlanetId` to SaveData
- Validation: Lock to planet â†’ save â†’ quit â†’ reload â†’ verify lock restored

**3. Sprite Atlas â†” All Features**
- File: `StarSystemLoader.cs`
- Issue: Atlas must load all sprites used by all features
- Validation: Verify no "missing sprite" errors in console

### Quality Gates

**Per-Workflow Gates:**
- **Workflow A:** Kids (5-8) can reach planets easily
- **Workflow B:** Zero data loss on mobile (or Editor simulation)
- **Workflow C:** 80%+ GC reduction measured
- **Workflow D:** <10 draw calls measured
- **Workflow E:** Zero Phase 1 regressions

**Phase-Level Gates:**
- All 23 deliverable checkboxes completed
- Mobile performance: 30 FPS sustained (Editor simulation acceptable)
- Build size increase: <5 MB
- No P0/P1 bugs
- Kid testing validates gravity lock

### Performance Targets

| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| Draw Calls | 100+ | <10 | 90% reduction |
| GC Allocations | 100KB/frame | 20KB/frame | 80% reduction |
| FPS (mobile) | ~20-25 | 30+ | 20%+ increase |
| Texture Memory | ~50 MB | ~10 MB | 80% reduction |

---

## Timeline Summary

**Phase 1 Core:** 3 weeks (existing plan)
**Phase 1.6 Mobile:** 3-4 days (this plan)
**Phase 1.5 Refactoring:** 3 days (existing plan)

**Total Phase 1 + Enhancements:** ~4.5 weeks

**Recommended Order:**
1. Phase 1 (Weeks 1-3): Core ship + JSON import
2. Phase 1.6 (Days 1-4): Mobile enhancements â† **THIS PLAN**
3. Phase 1.5 (Days 1-3): Logic extraction refactoring

**Rationale:** Implement mobile features before refactoring so refactoring can include them.

---

## Success Criteria

Phase 1.6 is complete when:
- âœ… Kids ages 5-8 can easily approach moving planets (gravity lock validated)
- âœ… Mobile sessions save/resume automatically (no data loss)
- âœ… Frame rate stable at 30 FPS on mobile (profiler confirmed)
- âœ… Draw calls reduced from 100+ to < 10 (atlas working)
- âœ… All Phase 1 tests still pass (no regressions)

---

## File Structure Additions

```
Assets/
â”œâ”€â”€ _Project/
â”‚   â”œâ”€â”€ Scripts/
â”‚   â”‚   â”œâ”€â”€ Player/
â”‚   â”‚   â”‚   â”œâ”€â”€ PlayerShipController.cs (updated)
â”‚   â”‚   â”‚   â””â”€â”€ GravityLockSystem.cs (new)
â”‚   â”‚   â”œâ”€â”€ StarSystem/
â”‚   â”‚   â”‚   â”œâ”€â”€ StarSystemLoader.cs (updated - atlas support)
â”‚   â”‚   â”‚   â””â”€â”€ CelestialBodyController.cs (updated - orbital velocity)
â”‚   â”‚   â”œâ”€â”€ Save/
â”‚   â”‚   â”‚   â”œâ”€â”€ SaveManager.cs (updated - autosave)
â”‚   â”‚   â”‚   â”œâ”€â”€ SaveData.cs (updated - timestamp)
â”‚   â”‚   â”‚   â””â”€â”€ BootController.cs (new)
â”‚   â”‚   â””â”€â”€ Core/
â”‚   â”‚       â”œâ”€â”€ ObjectPool.cs (new)
â”‚   â”‚       â””â”€â”€ PoolManager.cs (new)
â”‚   â”‚
â”‚   â”œâ”€â”€ Prefabs/
â”‚   â”‚   â””â”€â”€ PlanetLockIndicator.prefab (new)
â”‚   â”‚
â”‚   â””â”€â”€ Art/
â”‚       â””â”€â”€ Atlases/
â”‚           â””â”€â”€ CelestialsAtlas.spriteatlas (new)
```

---

## Quick Start Guide - Ready to Execute

### For Solo Developers (Recommended: High Priority Only)

**Step 1: Start with Workflow A (Gravity Lock) - Day 1**
1. Read `PlayerShipController.cs` and `CelestialBodyController.cs` (Task A1)
2. Create `GravityLockSystem.cs` (Task A2)
3. Update celestial body and ship controllers (Tasks A3-A4)
4. Create lock indicator prefab (Task A5)
5. Test in Unity Editor play mode (Task A6)

**Step 2: Continue with Workflow B (Autosave) - Day 2**
1. Analyze current `SaveManager.cs` and `SaveData.cs` (Task B1)
2. Add auto-save logic with timers and lifecycle hooks (Task B2)
3. Extend SaveData with timestamps and ship state (Task B3)
4. Create `BootController.cs` for auto-load (Task B4)
5. Test with Unity Editor pause simulation (Task B5)

**Step 3: Integration & Polish - Day 3**
1. Test both features working together
2. Run all Phase 1 tests (verify no regressions)
3. Bug fixes and refinements
4. Update documentation

**Files to Create (4):**
- `Assets/_Project/Scripts/Player/GravityLockSystem.cs`
- `Assets/_Project/Scripts/Save/BootController.cs`
- `Assets/_Project/Prefabs/PlanetLockIndicator.prefab`
- `.plans/phases/phase1/1.6-progress.json` (optional tracking)

**Files to Modify (4):**
- `Assets/_Project/Scripts/Player/PlayerShipController.cs`
- `Assets/_Project/Scripts/StarSystem/CelestialBodyController.cs`
- `Assets/_Project/Scripts/Save/SaveManager.cs`
- `Assets/_Project/Scripts/Save/SaveData.cs`

### Testing Without Mobile Devices

**Gravity Lock Testing (Unity Editor):**
- Play mode: approach planets at various speeds/angles
- Verify lock triggers at 2x planet radius
- Test attraction and orbital following
- Confirm indicator appears/disappears
- Validate player thrust override

**Autosave Testing (Unity Editor):**
- Use `Debug.Log()` to verify auto-save triggers
- Simulate pause: Editor â†’ File â†’ Pause (or create test button calling `OnApplicationPause(true)`)
- Test persistence: save â†’ stop play mode â†’ restart â†’ verify ship position restored
- Timer test: play for 5+ minutes, check auto-save triggers

### When to Add Workflows C & D

**Add Later When:**
- Mobile devices available for actual testing
- Performance profiling shows GC issues (add Workflow C)
- Draw calls measured >30 in production (add Workflow D)
- Phase 2+ features need performance optimization

Both workflows are fully documented above and can be added independently anytime.

### Progress Tracking

Create `.plans/phases/phase1/1.6-progress.json` to track state:
- Update workflow states: NOT_STARTED â†’ IN_PROGRESS â†’ COMPLETE
- Track completed tasks (A1, A2, etc.)
- Note any blockers encountered
- Estimate completion %

---

*Phase 1.6 focuses on mobile experience - making the game accessible and performant for kids on tablets* ðŸš€ðŸ“±
