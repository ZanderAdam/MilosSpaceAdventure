# Interactive System Map - UI Toolkit Migration Plan
## Milo's Space Adventure - Phase 1.7.2

> **ðŸŽ¨ UI Toolkit Implementation:** This plan migrates BOTH the existing minimap and planned interactive map from legacy uGUI (Canvas/RectTransform/Image) to modern Unity UI Toolkit (UXML/USS/VisualElement). Total estimate: **14-21 hours** across **7 phases** (includes coordinate conversion infrastructure, C# animations, and performance optimizations).

---

## Mikado Goal

**Migrate BOTH minimap and interactive map to Unity's UI Toolkit, implementing:**
- PC: Press 'M' key to open fullscreen interactive map
- Mobile: Tap minimap icon to open
- **UI Toolkit Implementation:** UXML layouts, USS styling, custom VisualElements

**Features:**
- Fullscreen modal overlay showing all planets with larger icons
- Clickable planets (DPI-adaptive touch zones â‰¥44pt) displaying info panel
- Player ship icon with pulse animation
- Selected planet highlight with pulsing ring
- Dimmed background (tap to close on mobile)
- Close button (X) and ESC key support
- Disables player controls when open (world continues running)
- **Modern UI:** USS animations, data binding, responsive layouts

---

## Current State Analysis

### âœ… Already Implemented (uGUI - To Be Migrated)

1. **Minimap.cs** - Fully functional uGUI minimap
   - Path: `/Assets/_Project/Scripts/UI/Minimap.cs`
   - Shows all planets as colored dots (creates sprites programmatically)
   - Shows player ship with rotation indicator (triangle sprite)
   - Has `OnMinimapTapped()` placeholder at line 112
   - Mobile button already configured
   - **WorldToMinimapPosition()** logic (lines 478-496) - REUSE for UI Toolkit
   - Creates Canvas/RectTransform hierarchy at runtime
   - **STATUS:** Will be replaced by MinimapController.cs using UI Toolkit

2. **StarSystemRenderer.GetAllBodies()** - EXISTS and ready to use
   - Path: `/Assets/_Project/Scripts/StarSystem/StarSystemRenderer.cs` (lines 80-85)
   - Returns `CelestialBodyController[]` array
   - Can iterate all bodies for icon creation
   - **Compatible with UI Toolkit** implementation

3. **Integration Patterns** - Confirmed working, compatible with UI Toolkit
   - Singleton pattern (SaveManager, StarSystemLoader)
   - Event subscription (OnSystemLoaded)
   - Platform detection (Application.isMobilePlatform)

### âŒ Not Yet Implemented - UI Toolkit Infrastructure

1. **UI Toolkit Directory Structure** - Does not exist
   - No `/Assets/_Project/UI/` directory
   - No UXML files (layout)
   - No USS files (styling)
   - No custom VisualElement classes

2. **CelestialBodyController.Description** - Property missing
   - Data exists in JSON (`CelestialBodyJson.description`)
   - Needs public property: `public string Description => _data?.description ?? "";`

3. **MinimapController.cs** (UI Toolkit version) - Does not exist
   - Replaces Minimap.cs with UIDocument approach
   - Uses UXML/USS for layout/styling
   - Proves UI Toolkit pattern before building interactive map

4. **InteractiveMapController.cs** - Does not exist
   - Fullscreen map using UI Toolkit
   - Custom VisualElements for planet icons
   - Data binding for info panel

5. **MapInputManager.cs** - Does not exist
   - Singleton to handle M key toggle
   - Disable/enable player controls
   - Coordinate minimap tap â†’ interactive map open

### ðŸ”„ Migration Strategy

**Phase 1: Infrastructure** â†’ Create UI Toolkit foundation (UXML/USS/Utils)
**Phase 2: Minimap Migration** â†’ Prove UI Toolkit pattern works (less risky than starting with interactive map)
**Phase 3: Interactive Map** â†’ Build on proven foundation
**Phase 4+: Integration & Polish** â†’ Wire everything together

---

## Mikado Dependency Graph (UI Toolkit)

### ðŸŽ¯ GOAL: Interactive System Map with UI Toolkit
**Prerequisites:**
  - [ ] UI Toolkit infrastructure exists (UXML/USS/Utils)
  - [ ] MinimapController migrated and working (proves pattern)
  - [ ] InteractiveMapController exists and displays map
  - [ ] MapInputManager singleton coordinates toggle

---

### Prerequisite A: UI Toolkit Infrastructure
**What breaks without this:** No foundation for building UI Toolkit components
**Prerequisites:**
  - [ ] A1: Directory structure created (LEAF)
  - [ ] A2: Theme.uss with CSS variables (LEAF)
  - [ ] A3: TouchTargetCalculator.cs utility (LEAF)
  - [ ] A4: PlanetIconElement custom VisualElement (LEAF)

**Implementation:**
- Create `/Assets/_Project/UI/` with UXML, USS, Scripts subdirectories
- Theme.uss defines colors, spacing, timing, easing (--color-star, --duration-transition, etc.)
- TouchTargetCalculator calculates DPI-adaptive sizes (44pt minimum physical)
- PlanetIconElement provides reusable planet icon component

**Why This First:** Proves UI Toolkit works before touching existing minimap

---

### Prerequisite B: MinimapController (UI Toolkit Version)
**What breaks without this:** No proven pattern for UI Toolkit implementation
**Prerequisites:**
  - [ ] B1: UI Toolkit infrastructure exists (depends on A)
  - [ ] B2: Minimap.uxml layout created (LEAF)
  - [ ] B3: Minimap.uss styling created (LEAF)
  - [ ] B4: MinimapController.cs script created (LEAF)
  - [ ] B5: Can access StarSystemRenderer.GetAllBodies() (LEAF - âœ… EXISTS)

**Implementation:**
- Create Minimap.uxml using UI Builder (container, background, planets, player icon)
- Create Minimap.uss with responsive positioning (--top-right, --mobile classes)
- MinimapController.cs uses UIDocument to query elements
- Reuse WorldToMinimapPosition() logic from old Minimap.cs (lines 478-496)
- 10Hz update throttling (not 60Hz) for performance

**Why This Second:** Minimap is simpler than interactive map, less risk
**Validation:** Keep old Minimap.cs as reference, test side-by-side

---

### Prerequisite C: InteractiveMapController (UI Toolkit)
**What breaks without this:** No fullscreen map to display
**Prerequisites:**
  - [ ] C1: MinimapController working (depends on B - pattern proven)
  - [ ] C2: InteractiveMap.uxml layout created (LEAF)
  - [ ] C3: InteractiveMap.uss + Animations.uss styling (LEAF)
  - [ ] C4: PlanetInfoPanelElement custom component (LEAF)
  - [ ] C5: InteractiveMapController.cs script created (LEAF)
  - [ ] C6: CelestialBodyController.Description property exists (LEAF)

**Implementation:**
- InteractiveMap.uxml: fullscreen overlay, map panel, dimmed background, close button
- Animations.uss: @keyframes pulse, fade-in with --ease-out-cubic
- PlanetInfoPanelElement with data binding (name, type, description, icon)
- InteractiveMapController manages planet icons, selection, info display
- Adaptive touch targets (DPI-based sizing, cluster detection)

**Why This Third:** Builds on proven MinimapController pattern

---

### Prerequisite D: MapInputManager Singleton
**What breaks without this:** No way to coordinate map open/close globally
**Prerequisites:**
  - [ ] D1: Can get reference to PlayerShipController (LEAF)
  - [ ] D2: Can get reference to InteractiveMapController (LEAF)
  - [ ] D3: MapInputManager.cs script created (LEAF)

**Implementation:**
- Create `/Assets/_Project/UI/Scripts/MapInputManager.cs`
- Singleton pattern (follow SaveManager.cs)
- Toggle method disables controls: `playerShipController.enabled = false`
- Listen for M key in Update()
- try-finally to ensure controls re-enable on error

---

### Prerequisite E: Minimap Integration
**What breaks without this:** Mobile users can't open map via tap
**Prerequisites:**
  - [ ] E1: MapInputManager singleton accessible (depends on D)
  - [ ] E2: Update MinimapController to call ToggleMap() on tap (LEAF)

**Implementation:**
- MinimapController.OnMinimapTapped() calls MapInputManager.Instance?.ToggleMap()
- Register ClickEvent callback on mobile: `_minimapContainer.RegisterCallback<ClickEvent>(OnMinimapTapped)`

---

## Execution Order (Bottom-Up) - UI Toolkit Approach

### Phase 1: UI Toolkit Infrastructure Setup (2-3 hours)
**Goal:** Create foundation for UI Toolkit implementation

1. **Create directory structure** (LEAF)
   ```bash
   mkdir -p Assets/_Project/UI/UXML/Minimap
   mkdir -p Assets/_Project/UI/UXML/InteractiveMap
   mkdir -p Assets/_Project/UI/USS
   mkdir -p Assets/_Project/UI/Scripts/CustomElements
   mkdir -p Assets/_Project/UI/Scripts/Utils
   ```

2. **Create Theme.uss** (LEAF)
   - File: `/Assets/_Project/UI/USS/Theme.uss`
   - Define CSS variables:
     - Colors: `--color-star` (yellow), `--color-planet` (cyan), `--color-player` (green)
     - Spacing: `--spacing-xs` through `--spacing-lg`
     - Timing: `--duration-instant` (0.1s), `--duration-action` (0.5s), `--duration-transition` (0.8s)
     - Easing: `--ease-out-cubic` for smooth transitions
   - Test by creating simple Label in UI Builder

3. **Create TouchTargetCalculator.cs** (LEAF - Pure Logic)
   - File: `/Assets/_Project/UI/Scripts/Utils/TouchTargetCalculator.cs`
   - Static class with `GetTouchTargetPixels(float physicalPoints = 44f)`
   - Formula: `(physicalPoints / 160dpi) * Screen.dpi`
   - Method: `GetAdaptiveTouchTarget()` for planet density detection
   - Write unit tests (15+ test cases)

4. **Create PlanetIconElement.cs** (LEAF)
   - File: `/Assets/_Project/UI/Scripts/CustomElements/PlanetIconElement.cs`
   - Custom VisualElement with UxmlFactory
   - Properties: PlanetId, IconColor
   - Test instantiation in UI Builder

5. **Add CelestialBodyController.Description property** (LEAF)
   - File: `/Assets/_Project/Scripts/StarSystem/CelestialBodyController.cs`
   - Location: After line 20
   - Code: `public string Description => _data?.description ?? "";`

**Validation Phase 1:**
- [ ] Directories visible in Unity Project window
- [ ] Theme.uss applies to test Label
- [ ] TouchTargetCalculator tests pass
- [ ] PlanetIconElement instantiates in UI Builder

---

### Phase 1.5: Coordinate Conversion & Technical Infrastructure (2-3 hours)
**Goal:** Establish coordinate conversion and sprite loading patterns

**Why This Phase:** UI Toolkit coordinate system differs from uGUI - validate conversion early

1. **Create CoordinateConverter.cs** (LEAF)
   - File: `/Assets/_Project/UI/Scripts/Utils/CoordinateConverter.cs`
   - Static class with pure functions
   - Method: `WorldToUIPosition(Vector3 worldPos, Vector2 worldSize, Vector2 uiSize)`
   - Handles world space â†’ UI Toolkit coordinates
   - **Key Difference from uGUI:** UI Toolkit uses top-left origin, uGUI uses center-anchor
   ```csharp
   public static Vector2 WorldToUIPosition(Vector3 worldPos, Vector2 worldSize, Vector2 uiSize)
   {
       // Normalize to 0-1 range (world center is 0,0)
       Vector2 normalized = (worldPos + worldSize / 2f) / worldSize;

       // UI Toolkit: (0,0) is top-left, so flip Y axis
       normalized.y = 1f - normalized.y;

       // Scale to UI size
       return normalized * uiSize;
   }
   ```

2. **Create SpriteLoader.cs** (LEAF)
   - File: `/Assets/_Project/UI/Scripts/Utils/SpriteLoader.cs`
   - Static cache: `Dictionary<string, Sprite> _spriteCache`
   - Method: `LoadSprite(string resourcePath)` - Returns cached Sprite
   - Extension: `SetBackgroundSprite(this VisualElement element, Sprite sprite)`
   ```csharp
   public static void SetBackgroundSprite(this VisualElement element, Sprite sprite)
   {
       if (sprite != null)
       {
           element.style.backgroundImage = new StyleBackground(sprite);
           element.style.unityBackgroundScaleMode = ScaleMode.ScaleToFit;
       }
   }
   ```

3. **Create PanelSettings Asset** (LEAF)
   - Create via: Assets â†’ Create â†’ UI Toolkit â†’ Panel Settings Asset
   - Name: `MinimapPanelSettings.asset`
   - Reference Resolution: 1920x1080
   - Scale Mode: Scale With Screen Size
   - Match: 0.5 (balanced width/height)
   - Fallback DPI: 96

4. **Create ColorUtility.cs** (LEAF)
   - File: `/Assets/_Project/UI/Scripts/Utils/ColorUtility.cs`
   - Method: `ParseHex(string hex)` - Converts "#FF5733" â†’ Color
   - Used for CelestialBodyJson.fallbackColor parsing

5. **Unit Tests for Coordinate Conversion** (LEAF)
   - File: `/Assets/_Project/Tests/EditMode/CoordinateConverterTests.cs`
   - Test 9 positions: center, 4 corners, 4 edges
   - Verify world (0,0) â†’ UI center
   - Verify world bounds â†’ UI bounds
   - Test on multiple UI sizes (150x150, 800x800)

**Validation Phase 1.5:**
- [ ] CoordinateConverter tests pass (9 positions)
- [ ] Sprite loading works (test with minimap sprites)
- [ ] PanelSettings asset created and configured
- [ ] ColorUtility.ParseHex handles "#RRGGBB" and "#RRGGBBAA"

---

### Phase 2: Minimap Migration to UI Toolkit (3-4 hours)
**Goal:** Migrate existing Minimap.cs to UI Toolkit (proves pattern works)

6. **Create Minimap.uxml** (Use UI Builder)
   - File: `/Assets/_Project/UI/UXML/Minimap/Minimap.uxml`
   - Structure:
     - minimap-container (VisualElement)
     - minimap-background (VisualElement)
     - planets-container (VisualElement)
     - player-icon (VisualElement)
   - Link Theme.uss and Minimap.uss

7. **Create Minimap.uss** (LEAF)
   - File: `/Assets/_Project/UI/USS/Minimap.uss`
   - Classes: `.minimap`, `.minimap--mobile`, `.minimap--top-right`
   - Responsive sizing (150px desktop, 120px mobile)
   - Position classes for all 4 corners

8. **Create MinimapController.cs** (LEAF)
   - File: `/Assets/_Project/UI/Scripts/MinimapController.cs`
   - MonoBehaviour with UIDocument reference
   - Query elements: `_root.Q("minimap-container")`
   - **Use CoordinateConverter.WorldToUIPosition()** instead of old logic
   - 10Hz update throttling: `UPDATE_INTERVAL = 0.1f`
   - ApplySafeAreaPadding() for notched devices
   - **Mobile event handling:** Use `PointerDownEvent` (not ClickEvent)
   ```csharp
   private void SetupMobileButton()
   {
       if (Application.isMobilePlatform && _minimapContainer != null)
       {
           _minimapContainer.RegisterCallback<PointerDownEvent>(evt =>
           {
               if (evt.button == 0) // Primary pointer (left mouse or touch)
                   OnMinimapTapped();
           });
       }
   }
   ```

9. **Test minimap side-by-side** (LEAF)
   - Disable old Minimap.cs (keep as reference)
   - Enable MinimapController.cs
   - Verify identical functionality
   - Compare planet positions, colors, rotation

10. **Delete old Minimap.cs** (AFTER VALIDATION)
    - Only after Phase 2 validation complete
    - Archive old code in commit message if needed

**Validation Phase 2:**
- [ ] Minimap appears in correct corner
- [ ] Planet icons match old colors
- [ ] Player icon rotates correctly
- [ ] Position updates at 10Hz
- [ ] Mobile size correct (120px)
- [ ] Safe area padding applied

---

### Phase 3: Interactive Map Foundation (2-3 hours)
**Goal:** Build fullscreen interactive map using UI Toolkit

11. **Create InteractiveMap.uxml** (Use UI Builder)
    - File: `/Assets/_Project/UI/UXML/InteractiveMap/InteractiveMap.uxml`
    - Structure:
      - fullscreen-overlay (VisualElement)
      - dimmed-background (Button - tap to close)
      - map-panel (VisualElement - 80% screen)
      - planets-container (VisualElement)
      - player-icon (VisualElement)
      - selection-highlight (VisualElement)
      - close-button (Button with "âœ•")
      - info-panel (PlanetInfoPanelElement)

12. **Create Animations.uss** (LEAF)
    - File: `/Assets/_Project/UI/USS/Animations.uss`
    - `@keyframes pulse` (1.5s, ease-in-out, infinite)
    - `@keyframes fade-in` (0.8s, ease-out cubic)
    - `.touchable:hover` and `:active` states

13. **Create InteractiveMap.uss** (LEAF)
    - File: `/Assets/_Project/UI/USS/InteractiveMap.uss`
    - `.map-overlay`, `.map-panel`, `.info-panel` classes
    - Responsive layout (flex properties)
    - Animation classes (`.animated-pulse`, `.animated-fade-in`)

14. **Create PlanetInfoPanelElement.cs** (LEAF)
    - File: `/Assets/_Project/UI/Scripts/CustomElements/PlanetInfoPanelElement.cs`
    - Custom VisualElement with data binding
    - Properties: PlanetName, PlanetType, PlanetDescription
    - Method: `SetPlanetData(CelestialBodyController)`
    - Show/Hide with USS class toggles

15. **Create InteractiveMapController.cs** (LEAF)
    - File: `/Assets/_Project/UI/Scripts/InteractiveMapController.cs`
    - MonoBehaviour with UIDocument reference
    - Methods:
      - `ShowMap()` - Create planet icons with adaptive sizing
      - `HideMap()` - Clear icons, hide overlay
      - `OnPlanetClicked(string planetId)` - Show info panel
      - `UpdatePlanetPositionsBatch()` - Batch updates (single pass)
      - `UpdatePlayerIcon()` - Pulse animation
    - Event wiring: close button, dimmed background, ESC key
    - **Performance optimizations:**
      - **Viewport culling:** Skip off-screen icons
      - **Dirty tracking:** Only update if moved >1px
      - **Batch updates:** Single update pass, not per-icon
    ```csharp
    private void UpdatePlanetPositionsBatch()
    {
        if (!_isVisible) return;

        Vector2 cameraPos = _mainCamera.transform.position;
        Rect viewport = new Rect(0, 0, _mapPanelSize, _mapPanelSize);

        foreach (var kvp in _planetIcons)
        {
            var body = kvp.Key;
            var icon = kvp.Value;
            if (body == null || icon == null) continue;

            Vector2 newPos = CoordinateConverter.WorldToUIPosition(
                body.transform.position,
                new Vector2(_worldSize, _worldSize),
                new Vector2(_mapPanelSize, _mapPanelSize)
            );

            // Dirty tracking: Only update if moved >1px
            Vector2 currentPos = new Vector2(icon.style.left.value.value, icon.style.top.value.value);
            if (Vector2.Distance(currentPos, newPos) < 1f) continue;

            // Viewport culling: Skip off-screen icons
            if (!viewport.Contains(newPos))
            {
                icon.style.display = DisplayStyle.None;
                continue;
            }

            icon.style.display = DisplayStyle.Flex;
            icon.style.left = newPos.x;
            icon.style.top = newPos.y;
        }
    }
    ```

**Validation Phase 3:**
- [ ] Map opens fullscreen
- [ ] Planets clickable with adaptive touch zones
- [ ] Info panel displays correct data
- [ ] Selection highlight appears
- [ ] Close button, dimmed bg, ESC work
- [ ] Player icon pulses

---

### Phase 4: MapInputManager Integration (1-2 hours)
**Goal:** Wire up M key toggle and control disable

16. **Create MapInputManager.cs** (LEAF)
    - File: `/Assets/_Project/UI/Scripts/MapInputManager.cs`
    - Singleton pattern (follow SaveManager.cs)
    - Fields: `_interactiveMapController`, `_playerShipController`
    - Method: `ToggleMap()` with try-finally for control re-enable
    - Update() listens for M key
    - OnDestroy() ensures controls re-enabled

17. **Update MinimapController.OnMinimapTapped()** (LEAF)
    - Call `MapInputManager.Instance?.ToggleMap()`

18. **Update InteractiveMapController.CloseMap()** (LEAF)
    - Call `MapInputManager.Instance?.ToggleMap()`

19. **Create MapInputManager GameObject in scene** (LEAF)
    - Add MapInputManager component
    - Wire references in Inspector

**Validation Phase 4:**
- [ ] M key opens/closes map
- [ ] Minimap tap opens map (mobile)
- [ ] Player controls disabled when open
- [ ] Controls re-enabled when closed
- [ ] Map closes on all inputs

---

### Phase 5: Visual Polish & Animations (2-3 hours)
**Goal:** Add C# animations, transitions, visual feedback

**Why C# Instead of USS:** Guarantee exact ease-out cubic (`Mathf.Pow(1f - progress, 3f)`) per CLAUDE.md standards. USS animations don't support precise cubic-bezier control.

20. **Implement C# animations using VisualElement.schedule** (LEAF)
    - **Pulse animation** for player icon (1.5s cycle)
    ```csharp
    private void StartPulseAnimation(VisualElement element)
    {
        element.schedule.Execute(() =>
        {
            float progress = (Time.time % 1.5f) / 1.5f; // 1.5s cycle
            float scale = 1f + Mathf.Sin(progress * Mathf.PI * 2f) * 0.15f;
            element.style.scale = new Scale(new Vector3(scale, scale, 1f));
        }).Every(16); // ~60 FPS
    }
    ```
    - **Fade-in animation** for map overlay (0.8s, ease-out cubic)
    ```csharp
    private void FadeIn(VisualElement element, float duration = 0.8f)
    {
        float startTime = Time.time;
        element.schedule.Execute(() =>
        {
            float elapsed = Time.time - startTime;
            float progress = Mathf.Clamp01(elapsed / duration);

            // CLAUDE.md standard: ease-out cubic
            float eased = 1f - Mathf.Pow(1f - progress, 3f);
            element.style.opacity = eased;

            if (progress >= 1f)
                element.schedule.Pause(); // Stop animation
        }).Every(16);
    }
    ```
    - **Touch feedback** via USS `:hover` and `:active` states (simple scale, no easing needed)

21. **Add DPI-adaptive sizing** (LEAF)
    - Calculate touch targets in CreatePlanetIcon()
    - Use TouchTargetCalculator.GetTouchTargetPixels(44f)
    - Apply adaptive sizing based on planet density
    - Test on high DPI device (300+ DPI)

22. **Color theming** (LEAF)
    - Stars: Yellow (--color-star)
    - Planets: Cyan (--color-planet)
    - Player: Green (--color-player)
    - Match colors from Minimap.cs

23. **Visual debug mode** (LEAF)
    - Add `[SerializeField] bool _showDebugOutlines`
    - Toggle USS class to show touch zones

**Validation Phase 5:**
- [ ] Animations smooth (60 FPS PC, 30 FPS mobile)
- [ ] Touch feedback <100ms
- [ ] DPI-adaptive sizing works
- [ ] Colors match theme
- [ ] Debug mode shows touch zones

---

### Phase 6: Testing & Validation (2-3 hours)
**Goal:** Verify all functionality and performance

24. **Unit Tests** (LEAF)
    - File: `/Assets/_Project/Tests/EditMode/TouchTargetCalculatorTests.cs`
    - Test GetTouchTargetPixels() at various DPIs (160, 320, 480)
    - Test GetAdaptiveTouchTarget() with sparse/clustered planets
    - 15+ test cases minimum

25. **Integration Tests** (LEAF)
    - M key toggle (open/close)
    - Minimap tap (open on mobile)
    - ESC key (close)
    - Close button (X)
    - Dimmed background tap (close on mobile)
    - Planet selection (info panel displays)
    - Data binding (correct planet name/type/description)

26. **Performance Profiling** (LEAF)
    - Frame time with map closed vs open (target: <1 FPS drop)
    - GC allocations in Update() (target: <100KB/frame)
    - Draw calls (target: <50)
    - Memory overhead (target: <1 MB)
    - Test with 75+ planets (worst case)

27. **Mobile Device Testing** (LEAF)
    - Touch targets â‰¥44pt minimum physical size
    - Safe area handling (notched devices)
    - DPI-adaptive sizing (verify on 3+ devices)
    - Performance (30 FPS minimum on low-end device)
    - Touch feedback (<100ms response)

28. **Edge Case Testing** (LEAF)
    - Open map before system loads (should be disabled)
    - Switch systems while map open (should update icons)
    - Rapid M key toggle (controls re-enable properly)
    - Select planet â†’ close map â†’ reopen (selection cleared)
    - Destroy MapInputManager while map open (controls re-enable)

**Validation Phase 6:**
- [ ] All unit tests pass
- [ ] All integration tests pass
- [ ] Performance targets met
- [ ] Touch targets verified on device
- [ ] Safe area handling correct
- [ ] No crashes or errors in 30 min session

---

## File Summary - UI Toolkit Implementation

### New UXML Files (3 files)
1. `/Assets/_Project/UI/UXML/Minimap/Minimap.uxml` - Minimap layout
2. `/Assets/_Project/UI/UXML/InteractiveMap/InteractiveMap.uxml` - Interactive map layout
3. `/Assets/_Project/UI/UXML/InteractiveMap/PlanetInfoPanel.uxml` - Info panel template (optional)

### New USS Files (4 files)
4. `/Assets/_Project/UI/USS/Theme.uss` - Global CSS variables (colors, spacing, timing)
5. `/Assets/_Project/UI/USS/Minimap.uss` - Minimap-specific styles
6. `/Assets/_Project/UI/USS/InteractiveMap.uss` - Interactive map styles
7. `/Assets/_Project/UI/USS/Animations.uss` - Keyframe animations (pulse, fade-in)

### New C# Scripts (11 files)
8. `/Assets/_Project/UI/Scripts/MinimapController.cs` - UI Toolkit minimap (replaces Minimap.cs)
9. `/Assets/_Project/UI/Scripts/InteractiveMapController.cs` - UI Toolkit interactive map
10. `/Assets/_Project/UI/Scripts/MapInputManager.cs` - Input manager singleton
11. `/Assets/_Project/UI/Scripts/CustomElements/PlanetIconElement.cs` - Custom VisualElement
12. `/Assets/_Project/UI/Scripts/CustomElements/MapPanelElement.cs` - Custom container (optional)
13. `/Assets/_Project/UI/Scripts/CustomElements/PlanetInfoPanelElement.cs` - Custom info panel
14. `/Assets/_Project/UI/Scripts/Utils/TouchTargetCalculator.cs` - DPI-adaptive sizing (pure logic)
15. `/Assets/_Project/UI/Scripts/Utils/CoordinateConverter.cs` - **Worldâ†’UI conversion (REQUIRED for Phase 1.5)**
16. `/Assets/_Project/UI/Scripts/Utils/SpriteLoader.cs` - **Sprite caching and loading (REQUIRED for Phase 1.5)**
17. `/Assets/_Project/UI/Scripts/Utils/ColorUtility.cs` - **Hex color parsing (REQUIRED for Phase 1.5)**
18. `/Assets/_Project/UI/Scripts/Utils/VisualElementExtensions.cs` - **SetBackgroundSprite extension method**

### New Unit Test Files (2 files)
19. `/Assets/_Project/Tests/EditMode/TouchTargetCalculatorTests.cs` - DPI sizing tests
20. `/Assets/_Project/Tests/EditMode/CoordinateConverterTests.cs` - **Coordinate conversion tests (REQUIRED for Phase 1.5)**

### New Assets (1 file)
21. `/Assets/_Project/UI/MinimapPanelSettings.asset` - **PanelSettings for UI scaling (REQUIRED for Phase 1.5)**

### Files to Modify (1 file)
22. `/Assets/_Project/Scripts/StarSystem/CelestialBodyController.cs` - Add Description property (line 20)

### Files to Delete (1 file - AFTER VALIDATION)
23. `/Assets/_Project/Scripts/UI/Minimap.cs` - Delete after Phase 2 validation complete

### Scene Setup (Unity Editor)
24. Create UIDocument GameObject for Minimap (assign Minimap.uxml, MinimapPanelSettings, add MinimapController component)
25. Create UIDocument GameObject for InteractiveMap (assign InteractiveMap.uxml, add InteractiveMapController component)
26. Create MapInputManager GameObject with component
27. Wire up references in Inspector (MapInputManager â†’ InteractiveMapController, PlayerShipController)

---

## Risk Assessment - UI Toolkit Migration

### ðŸ”´ HIGH RISK - Requires Careful Testing

**1. UI Toolkit Learning Curve**
- **Risk:** Team unfamiliar with UXML/USS/VisualElement patterns
- **Impact:** Implementation may take longer than uGUI approach
- **Mitigation:**
  - Start with minimap migration (simpler, less risky)
  - Keep old Minimap.cs as reference during Phase 2
  - Use UI Builder for visual feedback during development
  - Test incrementally after each phase

**2. Touch Target Sizing on Low DPI Devices**
- **Risk:** Touch targets too small on low DPI screens (<200 DPI)
- **Impact:** Kids (age 5-8) can't tap planets reliably
- **Mitigation:**
  - Enforce minimum 44pt physical size (Apple HIG)
  - Test on real devices (not just simulator)
  - Implement adaptive sizing (larger when planets sparse)
  - Add visual debug mode to show touch zones

**3. Coordinate Conversion Accuracy (World â†’ UI Toolkit)**
- **Risk:** Planet icons misaligned between minimap and interactive map
- **Impact:** Confusing UX, player can't locate planets
- **Mitigation:**
  - Reuse proven WorldToMinimapPosition() logic from Minimap.cs (lines 478-496)
  - Unit test coordinate conversion with known positions
  - Add debug Gizmos to visualize world vs UI positions
  - Test with extreme camera positions (edges, center, zoomed)

### ðŸŸ¡ MEDIUM RISK - Test Thoroughly

**4. UI Toolkit Performance on Mobile**
- **Risk:** UI Toolkit rendering slower than uGUI on older devices
- **Impact:** Frame rate drop >1 FPS, violates performance target
- **Mitigation:**
  - Profile early (Phase 3, not Phase 6)
  - Use object pooling for planet icons (100+ instances)
  - Throttle position updates to 10Hz (not 60Hz)
  - Use sprite atlas to minimize draw calls
  - Disable animations if frame time >33ms

**5. Data Binding Edge Cases**
- **Risk:** Stale data displayed when switching systems
- **Impact:** Info panel shows wrong planet details
- **Mitigation:**
  - Subscribe to StarSystemLoader.OnSystemLoaded event
  - Clear all bindings on system switch
  - Test: Open map â†’ load different system â†’ verify update

**6. Safe Area Handling on Notched Devices**
- **Risk:** Minimap or close button obscured by notch
- **Impact:** Cannot close map on certain devices
- **Mitigation:**
  - Test on iPhone X+ or Unity Device Simulator
  - Apply Screen.safeArea padding to root container
  - Add safe area debug visualization

**7. Player Control Disable/Enable**
- **Risk:** Controls might not re-enable properly if map closes unexpectedly
- **Impact:** Player stuck, cannot move ship
- **Mitigation:**
  - Use try-finally pattern in ToggleMap()
  - Add OnDestroy() to MapInputManager to force re-enable
  - Test rapid toggle scenarios (M key spam)

### ðŸŸ¢ LOW RISK - Standard Patterns

**8. Description Property Addition**
- Read-only property, no side effects
- Data already exists in JSON (_data field confirmed at line 8)

**9. Singleton Pattern**
- MapInputManager follows proven SaveManager pattern
- DontDestroyOnLoad ensures persistence

**10. UI Toolkit Event System**
- RegisterCallback<ClickEvent>() is standard UI Toolkit pattern
- Well-documented, stable API

---

## Performance Targets

| Metric | Target | Validation |
|--------|--------|------------|
| FPS Impact | <1 FPS drop | Profile with map open vs closed |
| GC Allocations | <100 KB/frame | Unity Profiler (Deep Profile) |
| Icon Creation Time | <50ms for 75 planets | Log time in ShowMap() |
| Update Frequency | 60 FPS (PC), 30 FPS (mobile) | Consistent frame time |
| Memory Overhead | <1 MB (icons + buttons) | Memory Profiler |

---

## Optional Enhancements (Phase 1.5+)

### Should-Have Features
- **Sound effects:** Soft whoosh on open/close, ping on planet select
- **Planet count badge:** Show total planets in top-right of map
- **Animation:** Fade-in map panel (0.2s ease-out)
- **Accessibility:** Colorblind-friendly planet shapes (circle/triangle/square)

### Nice-to-Have Features (Phase 2)
- **Pinch-to-zoom:** Scale map panel 1x to 3x (mobile only)
- **Distance indicators:** Show distance from player to planets
- **Swipe-to-close info panel:** Mobile gesture for quick dismiss
- **Center-on-player button:** Reset map view to player position
- **Distance rings:** Concentric circles at 10, 20, 30+ units

---

## Integration with Phase Plan

This implementation completes **Phase 1.7: Minimap System** as outlined in `1.7-minimap.md`.

**Phase 1.7 Deliverables:**
- âœ… Minimap HUD (completed - Minimap.cs)
- ðŸ”„ Interactive Map (this plan - 1.7.2)

**Next Phase:**
- **Phase 2:** Scanning mechanic (gray out unscanned planets on map)
- **Phase 2:** Objective markers (highlight mission target planets)

---

## Validation Checklist

Before marking Phase 1.7.2 complete, verify:

- [ ] M key opens/closes map on PC
- [ ] Tap minimap opens map on mobile
- [ ] Tap dimmed background closes map on mobile
- [ ] X button closes map on all platforms
- [ ] ESC key closes map on PC
- [ ] Player controls disabled when map open
- [ ] Player ship icon pulses on map
- [ ] Planets are clickable with 88x88 tap zones
- [ ] Info panel displays: name, type, description, icon
- [ ] Selected planet has pulsing highlight ring
- [ ] World continues running (ship drifts, planets orbit)
- [ ] Map updates automatically on system switch
- [ ] No compilation errors
- [ ] <1 FPS performance impact
- [ ] No GC allocations in Update loops
- [ ] Tested on mobile device (touch targets)

---

## Time Estimate - UI Toolkit Implementation

| Phase | Duration | Cumulative | Notes |
|-------|----------|------------|-------|
| 1. Infrastructure | 2-3 hours | 2-3h | Setup, utilities, base classes |
| **1.5. Coordinate & Sprite** | **2-3 hours** | **4-6h** | **Coordinate conversion, sprite loading, PanelSettings** |
| 2. Minimap Migration | 3-4 hours | 7-10h | Prove UI Toolkit pattern works |
| 3. Interactive Map | 2-3 hours | 9-13h | Build on proven foundation |
| 4. Integration | 1-2 hours | 10-15h | Wire up input and events |
| 5. Polish & Animations | 2-3 hours | 12-18h | C# animations, visual feedback |
| 6. Testing | 2-3 hours | 14-21h | Validation and profiling |

**Total Estimate:** 14-21 hours

**Why Longer Than uGUI Approach (6.5-9.5h)?**
- UI Toolkit learning curve (+2-3h)
- Migration of existing minimap (+1-2h)
- UXML/USS creation and iteration (+2-3h)
- Custom VisualElement implementation (+1-2h)
- **Coordinate conversion infrastructure (+2-3h)** - NEW
- C# animation implementation (replaces USS) (+1h)

**Time Savings:**
- No manual Canvas hierarchy creation (saves ~45 min)
- CoordinateConverter reusable for future features (saves ~2h long-term)
- Data binding reduces boilerplate (saves ~30 min)

**Recommended Schedule:**
- **Session 1 (3h):** Phase 1 (infrastructure)
- **Session 2 (3h):** Phase 1.5 (coordinate conversion, sprite loading)
- **Session 3 (4h):** Phase 2 (minimap migration)
- **Session 4 (3h):** Phase 3 (interactive map foundation)
- **Session 5 (2h):** Phase 4 (integration)
- **Session 6 (3h):** Phase 5 (polish & animations)
- **Session 7 (3h):** Phase 6 (testing)

---

## Success Criteria

**Minimum Viable Product (MVP):**
1. Minimap migrated to UI Toolkit with identical functionality
2. Interactive map opens via M key or minimap tap
3. Planets clickable and display info
4. Map closes properly and re-enables controls
5. No crashes or major bugs

**Phase 1.7.2 Complete:**
- All validation checklist items pass
- Performance targets met (<1 FPS drop, <100KB GC/frame)
- Mobile touch targets verified on device (â‰¥44pt physical)
- Code follows CLAUDE.md conventions (component structure, KISS, etc.)
- No test failures
- Both minimap and interactive map use UI Toolkit

**Phase 1.7 Series Complete:**
- Minimap + Interactive Map fully functional in UI Toolkit
- User can navigate large star systems (75+ planets)
- Kid-friendly UX (ages 5-8, no tutorials needed)
- Modern UI foundation (UXML/USS/VisualElement patterns established)
- 60 FPS PC, 30 FPS mobile
- Safe area handling correct for notched devices
- Ready for Phase 2 (scanning mechanic integration)

---

## Notes for Implementation

1. **Start with Infrastructure:** Get directory structure and utilities right first, don't touch existing code yet
2. **Migrate Minimap First:** Prove UI Toolkit pattern works before building interactive map (less risky)
3. **Test Incrementally:** After each phase, verify that phase works independently before proceeding
4. **Use UI Builder:** Create initial layouts visually, then hand-edit UXML/USS for refinement (hybrid approach)
5. **Reuse Proven Logic:** Copy WorldToMinimapPosition() from Minimap.cs (lines 478-496), don't reinvent
6. **Profile Early:** Check performance after Phase 3 (not Phase 6) to catch issues when they're cheaper to fix
7. **Mobile-First:** Test touch targets on actual device (Unity Remote or build), not just editor simulator
8. **KISS Principle:** Avoid over-engineering custom VisualElements; start simple, iterate if needed
9. **Keep Old Code:** Don't delete Minimap.cs until Phase 2 validation complete (use as reference)
10. **Document Learnings:** UI Toolkit patterns will be reused in future phases (scanning UI, menus, HUD)

---

## Related Documentation

- **Phase Plan:** `.plans/phases/phase1/1.7-minimap.md` (parent plan)
- **Project Guidelines:** `CLAUDE.md` (coding standards)
- **Architecture:** `.plans/context/project-plan.md` (overall project)
- **Reference Implementations:**
  - Minimap.cs (position conversion, sprite creation)
  - MobileControls.cs (button setup, platform detection)
  - SaveManager.cs (singleton pattern)
  - DebugHUD.cs (UI panel management)
